<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2021/12/10/Redis/"/>
    <url>/2021/12/10/Redis/</url>
    
    <content type="html"><![CDATA[<p> 本篇文章是根据<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">黑马程序员</a>出品的视频，学习所做的笔记</p><h1 id="1-Redis的简单介绍"><a href="#1-Redis的简单介绍" class="headerlink" title="1. Redis的简单介绍"></a>1. Redis的简单介绍</h1><p><strong>概念：</strong>Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的<em>高性能键值对（key-value）数据库。</em></p><p><strong>类型</strong>：非关系型数据库（Nosql）</p><p><strong>特征：</strong></p><ul><li>可扩容，可伸缩</li><li>大数据量下高性能</li><li>灵活的数据模型</li><li>高可用</li></ul><p><strong>关键词：</strong>单线程、高性能、多数据类型、持久化</p><h1 id="2-Redis的应用"><a href="#2-Redis的应用" class="headerlink" title="2. Redis的应用"></a>2. Redis的应用</h1><ul><li>为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等</li><li>任务队列，如秒杀、抢购、购票排队等</li><li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设<br>备信号等 </li><li>时效性信息控制，如验证码控制、投票控制等</li><li>分布式数据共享，如分布式集群架构中的 session 分离</li><li>消息队列</li><li>分布式锁</li></ul><h1 id="3-Redis的五大数据类型"><a href="#3-Redis的五大数据类型" class="headerlink" title="3. Redis的五大数据类型"></a>3. Redis的五大数据类型</h1><p>​        <strong>redis                             java</strong></p><ul><li><p>String                          String</p></li><li><p>hash                          HashMap</p></li><li><p>list                             LinkedList</p></li><li><p>set                              HashSet</p></li><li><p>sortedset(zset)          TreeSet</p><p>数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串</p></li></ul><h1 id="4-Redis对不同数据类型的常见命令"><a href="#4-Redis对不同数据类型的常见命令" class="headerlink" title="4. Redis对不同数据类型的常见命令"></a>4. Redis对不同数据类型的常见命令</h1><h2 id="4-1-String"><a href="#4-1-String" class="headerlink" title="4.1 String"></a>4.1 String</h2><ul><li> 存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li><li> 存储数据的格式：一个存储空间保存一个数据</li><li>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</li></ul><ol><li><strong>基本命令：</strong></li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">set <span class="hljs-built_in">key</span> value                                         [添加/修改单条数据]<br><span class="hljs-built_in">get</span> <span class="hljs-built_in">key</span>                                               [获取单条数据]<br><span class="hljs-built_in">del</span> <span class="hljs-built_in">key</span>                                               [删除数据]<br>setex <span class="hljs-built_in">key</span>  <span class="hljs-built_in">second</span> value                               [设置<span class="hljs-built_in">key</span>的生命周期]<br>incr <span class="hljs-built_in">key</span>                                              [为某一个<span class="hljs-built_in">key</span>做自增操作，++<span class="hljs-built_in">key</span>]<br>decr <span class="hljs-built_in">key</span> <br></code></pre></td></tr></table></figure><ol start="2"><li><strong>其他命令:</strong></li></ol><blockquote><p><strong>mset</strong> key1 value1 key2 value2 … 【添加/修改多条数据】</p><p><strong>mget</strong> key1 key2 …                                【获取多条数据】</p><p><strong>strlen</strong> key                                    【获取数据字符个数（字符串长度）】</p><p><strong>append</strong> key value       [ 追加信息到原始信息后部（如果原始信息存在就追加，否则新建）]</p></blockquote><p>set 和 mset之间的选择问题：如果查询数据量较多时，可以选择mset来节约服务器与redis之间的往返时间</p><blockquote><p><strong>incrby</strong>  key   increment                         【为某一个key加上increment，但只能是整数】</p><p><strong>incrbyfloat</strong> key increment                  【为某一个key加上increment，可以是小数】</p><p><strong>decrby</strong> key increment</p></blockquote><p>string 作为数值操作:</p><ul><li><p>string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算。</p></li><li><p>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发<br>带来的数据影响。</p></li><li><p>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。<br>9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</p><p>string 类型数据操作的注意事项</p><blockquote><p> <strong>数据操作不成功的反馈与数据正常操作之间的差异</strong></p><p>① 表示运行结果是否成功</p><p>(integer) 0 → false 失败<br> (integer) 1 → true  成功<br>② 表示运行结果值<br> (integer) 3 → 3 3个<br>(integer) 1 → 1 1个<br> <strong>数据未获取到</strong><br>（nil）等同于null<br><strong>数据最大存储量</strong><br>512MB<br> <strong>数值计算最大范围（java中的long的最大值）</strong><br>9223372036854775807</p></blockquote></li></ul><p><strong>业务场景</strong>：主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量</p><p><img src="C:\Users\QUEEN\Pictures\image-20211213201217943.png" alt="image-20211213201217943"></p><h2 id="4-2-hash"><a href="#4-2-hash" class="headerlink" title="4.2 hash"></a>4.2 hash</h2><ul><li>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</li><li>需要的存储结构：一个存储空间保存多个键值对数据</li><li>hash类型：底层使用哈希表结构实现数据存储</li></ul><p><img src="D:\Typo_stroimg\image-20211213201344887.png" alt="image-20211213201344887"></p><ol><li><strong>基本命令</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">hset key field value         [添加/修改数据]<br>hget key field               [获取数据]<br>hgetall key                  <br>hdel key field1 [field2]     [删除数据]      <br></code></pre></td></tr></table></figure><ol start="2"><li><strong>其他命令</strong> </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">hmset key field1 value1 field2 value2 … <br>hmget key field1 field2 … <br>hlen key                    [获取哈希表中field字段的数量]<br>hexists key field           [获取哈希表中是否存在指定的字段]<br>    <br>hkeys key                   [ 获取哈希表中所有的字段名或字段值]<br>hvals key<br>hincrby key field increment [设置指定字段的数值数据增加指定范围的值]<br>hincrbyfloat key field increment<br></code></pre></td></tr></table></figure><p>hash 类型数据操作的注意事项 </p><ul><li><p>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，<br>对应的值为（nil）</p></li><li><p>hash 类型数据操作的注意事项</p></li><li><p>每个 hash 可以存储 2 32 - 1 个键值对</p></li><li><p>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存<br>储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用</p></li><li><p>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问<br>瓶颈</p></li></ul><p>对比：string存储对象（json）<strong>VS</strong> hash存储对象</p><p>String的好处：将对象的内容组装为一个整体，更倾向于<em>读取</em> </p><p>hash的好处：将对象的内容分成不同的field，更倾向于<em>更新</em></p><h2 id="4-3-list"><a href="#4-3-list" class="headerlink" title="4.3 list"></a>4.3 list</h2><ul><li> 数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</li><li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</li><li>list类型：保存多个数据，底层使用<strong>双向链表</strong>存储结构实现</li></ul><p><img src="D:\Typo_stroimg\list_1" alt="image-20211213202521627"></p><ol><li><p><strong>基本命令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">lpush key value1 [value2] ……        【 添加/修改数据】<br>rpush key value1 [value2] ……<br>  <br>lrange key start stop                【获取数据】<br>lindex key index<br>llen key <br>    <br>lpop key                            【获取并移除数据】<br>rpop key<br></code></pre></td></tr></table></figure></li><li><p><strong>其他命令</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">blpop key1 [key2] <span class="hljs-keyword">timeout</span>           [ 规定时间内获取并移除数据]<br>brpop key1 [key2] <span class="hljs-keyword">timeout</span><br>brpoplpush source destination <span class="hljs-keyword">timeout</span><br><br>lrem key <span class="hljs-built_in">count</span> value                [移除指定数据,<span class="hljs-built_in">count</span>表示为：移掉多少个]<br></code></pre></td></tr></table></figure><p>相当于阻塞，如果list中没有数据则阻塞，在规定的时间内有数据就输出并移除</p></li><li><p><strong>注意事项</strong></p><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2 32 - 1 个元素 (4294967295)。</li><li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作</li><li>获取全部数据操作结束索引设置为-1</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</li></ul></li><li><p><strong>业务场景</strong></p><ul><li>twitter、新浪微博、腾讯微博中个人用户的<strong>关注列表</strong>需要按照用户的关注顺序进行展示，粉丝列表需要将最<br>近关注的粉丝列在前面</li><li>新闻、资讯类网站如何将最新的新闻或资讯按照发生的<strong>时间顺序展示？</strong></li></ul></li></ol><h2 id="4-4-set"><a href="#4-4-set" class="headerlink" title="4.4 set"></a>4.4 set</h2><ul><li><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率</p></li><li><p>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</p></li><li><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的</p><p><img src="D:\Typo_stroimg\set1.png" alt="image-20211213203559389"></p></li></ul><ol><li>基本命令</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sadd</span> key member<span class="hljs-number">1</span><span class="hljs-meta"> [member2]        [添加数据]</span><br><span class="hljs-attribute">smembers</span> key                     <span class="hljs-meta"> [获取全部数据]</span><br><span class="hljs-attribute">srem</span> key member<span class="hljs-number">1</span><span class="hljs-meta"> [member2]        [删除数据]</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>其他命令</strong></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">scard key                         <span class="hljs-selector-attr">[获取集合数据总量]</span><br>sismember key member              <span class="hljs-selector-attr">[判断集合中是否包含指定数据]</span><br>srandmember key <span class="hljs-selector-attr">[count]</span>           <span class="hljs-selector-attr">[随机获取集合中指定数量的数据]</span><br>spop key <span class="hljs-selector-attr">[count]</span>                  <span class="hljs-selector-attr">[随机获取集合中的某个数据并将该数据移出集合]</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sinter</span> key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]               [求两个集合的交、并、差集]</span><br><span class="hljs-attribute">sunion</span> key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]</span><br><span class="hljs-attribute">sdiff</span> key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]</span><br><br><span class="hljs-attribute">sinterstore</span> destination key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]  [求两个集合的交、并、差集并存储到指定集合中]</span><br><span class="hljs-attribute">sunionstore</span> destination key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]</span><br><span class="hljs-attribute">sdiffstore</span> destination key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]</span><br><br><span class="hljs-attribute">smove</span> source destination member     <span class="hljs-meta"> [将指定数据从原始集合中移动到目标集合中]</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>注意事项</strong></li></ol><ul><li> set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份</li><li> set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间【set中的value类似于hash中的field】</li></ul><ol start="4"><li><strong>业务场景</strong></li></ol><ul><li>redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，<br>大V推荐等</li><li>新浪微博为了增加用户热度，提高用户留存性，需要微博用户在关注更多的人，以此获得更多的信息或热门<br>话题，如何提高用户关注他人的总量？</li><li>共同好友、共同关注等</li><li>redis 应用于同类型数据的快速去重</li><li>设置白名单或者黑名单</li></ul><h2 id="4-5-sorteds-set"><a href="#4-5-sorteds-set" class="headerlink" title="4.5 sorteds_set"></a>4.5 sorteds_set</h2><ul><li><p>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p></li><li><p>需要的存储结构：新的存储模型，可以保存可排序的数据</p></li><li><p>sorted_set类型：在set的存储结构基础上添加<strong>可排序字段</strong></p><p><img src="D:\Typo_stroimg\sorted_set.png" alt="image-20211213204419207"></p></li></ul><ol><li><p><strong>基本命令</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">zadd</span> <span class="hljs-selector-tag">key</span> <span class="hljs-selector-tag">score1</span> <span class="hljs-selector-tag">member1</span> <span class="hljs-selector-attr">[score2 member2]</span>           <span class="hljs-selector-attr">[添加数据]</span>  <br><br><span class="hljs-selector-tag">zrange</span> <span class="hljs-selector-tag">key</span> <span class="hljs-selector-tag">start</span> <span class="hljs-selector-tag">stop</span> <span class="hljs-selector-attr">[WITHSCORES]</span>                 <span class="hljs-selector-attr">[获取全部数据]</span>(升序)<br><span class="hljs-selector-tag">zrevrange</span> <span class="hljs-selector-tag">key</span> <span class="hljs-selector-tag">start</span> <span class="hljs-selector-tag">stop</span> <span class="hljs-selector-attr">[WITHSCORES]</span>               (降序)<br><br><span class="hljs-selector-tag">zrem</span> <span class="hljs-selector-tag">key</span> <span class="hljs-selector-tag">member</span> <span class="hljs-selector-attr">[member ...]</span>                       <span class="hljs-selector-attr">[删除数据]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>其他命令</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xquery">zrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> min</span><span class="hljs-built_in"> max</span> [WITHSCORES] [LIMIT]         [按条件获取数据]<br>zrevrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> max</span><span class="hljs-built_in"> min</span> [WITHSCORES]<br><br>zremrangebyrank<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> stop                         [条件删除数据]<br>zremrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> min</span><span class="hljs-built_in"> max</span><br><br></code></pre></td></tr></table></figure><ul><li> min与max用于限定搜索查询的条件</li><li> start与stop用于限定查询范围，作用于索引，表示开始和结束索引</li><li>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zcard <span class="hljs-built_in">key</span>                                              [获取集合数据总量]           <br>zcount <span class="hljs-built_in">key</span> <span class="hljs-built_in">min</span> <span class="hljs-built_in">max</span>                                     [集合交、并操作]<br><br>zrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>                                      [获取数据对应的索引（排名）]<br>zrevrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span><br>   <br>zscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>                                      score值获取与修改<br>zincrby <span class="hljs-built_in">key</span> increment <span class="hljs-built_in">member</span><br></code></pre></td></tr></table></figure></li><li><p><strong>注意事项</strong></p><ul><li> score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个<strong>双精度的double值</strong>，基于双精度浮点数的特征，可能会丢失精度，使用时<br>候要慎重</li><li>sorted_set 底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反<br>复覆盖，保留最后一次修改的结果</li></ul></li><li><p><strong>业务场景</strong></p><ul><li>票选广东十大杰出青年，各类综艺选秀海选投票</li><li>各类资源网站TOP10（电影，歌曲，文档，电商，游戏等）</li><li>聊天室活跃度统计</li><li>游戏好友亲密度</li><li>redis 应用于即时任务/消息队列执行管理(对于高优先级的任务要保障对其优先处理)</li></ul></li></ol><h2 id="4-6-数据类型实践案例"><a href="#4-6-数据类型实践案例" class="headerlink" title="4.6 数据类型实践案例"></a>4.6 数据类型实践案例</h2><p>业务场景：</p><p><img src="D:\Typo_stroimg\sorted_set2.png" alt="image-20211213205120772"></p><p><a href="https://www.bilibili.com/video/BV1CJ411m7Gc?p=32">代码实现</a></p><h1 id="5-Redis-通用指令"><a href="#5-Redis-通用指令" class="headerlink" title="5. Redis 通用指令"></a>5. Redis 通用指令</h1><h1 id="5-1-key-通用指令"><a href="#5-1-key-通用指令" class="headerlink" title="5.1 key 通用指令"></a>5.1 key 通用指令</h1><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs maxima">keys *       [查看所有的<span class="hljs-built_in">key</span>]<br><span class="hljs-built_in">del</span> <span class="hljs-built_in">key</span>      [删除指定的<span class="hljs-built_in">key</span>]<br>exists <span class="hljs-built_in">key</span>   [获取<span class="hljs-built_in">key</span>是否存在]<br>type <span class="hljs-built_in">key</span>     [获取<span class="hljs-built_in">key</span>的类型]<br>expire <span class="hljs-built_in">key</span> seconds [设置指定<span class="hljs-built_in">key</span>的有效期]<br>ttl <span class="hljs-built_in">key</span>       [获取指定<span class="hljs-built_in">key</span>的有效时间]<br>pttl <span class="hljs-built_in">key</span><br><span class="hljs-built_in">rename</span> <span class="hljs-built_in">key</span> newkey   [为<span class="hljs-built_in">key</span>改名]<br>renamenx <span class="hljs-built_in">key</span> newkey<br></code></pre></td></tr></table></figure><h2 id="5-2-数据库通用指令"><a href="#5-2-数据库通用指令" class="headerlink" title="5.2 数据库通用指令"></a>5.2 数据库通用指令</h2><ul><li><p>redis为每个服务提供有16个数据库，编号从0到15</p></li><li><p>每个数据库之间的数据相互独立</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">select</span> <span class="hljs-meta">index</span>   [切换数据库]<br><span class="hljs-keyword">quit</span><br><span class="hljs-keyword"></span>move <span class="hljs-meta">key</span> db    [数据移动]<br>dbsize         [数据清除]<br>flushdb<br>flushall<br></code></pre></td></tr></table></figure></li></ul><h1 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6 Jedis"></a>6 Jedis</h1><h2 id="6-1-准备工作"><a href="#6-1-准备工作" class="headerlink" title="6.1 准备工作"></a>6.1 准备工作</h2><ul><li><p>导入jedis坐标</p><blockquote><dependency><groupId>redis.clients</groupId><artifactId>jedis</artifactId><version>2.9.0</version></dependency></blockquote></li><li><p>连接jedis</p><blockquote><p>Jedis jedis = new Jedis(“localhost”, 6379);</p></blockquote></li><li><p>操作jedis</p></li><li><p>关闭jedis连接</p><blockquote><p>jedis.close();</p></blockquote></li></ul><h2 id="6-2-案例"><a href="#6-2-案例" class="headerlink" title="6.2 案例"></a>6.2 案例</h2><p><img src="D:\Typo_stroimg\jedis_1" alt="image-20211213212103850"></p><p><a href="https://www.bilibili.com/video/BV1CJ411m7Gc?p=44">代码演示</a></p><h2 id="6-3-jedis简易工具类开发"><a href="#6-3-jedis简易工具类开发" class="headerlink" title="6.3 jedis简易工具类开发"></a>6.3 jedis简易工具类开发</h2><p> JedisPool：Jedis提供的连接池技术</p><p>需要的三个内容：</p><p>poolConfig:连接池配置对象<br>host:redis服务地址<br>port:redis服务端口号</p><blockquote><p>//设置poolConfig</p><p>poolConfig = new JedisPoolConfig();<br>poolConfig.setMaxTotal(maxTotal);<br>poolConfig.setMaxIdle(maxIdle);</p><p>// 设置JedisPool</p><p>jedisPool = new JedisPool(poolConfig,host,port);</p></blockquote><h1 id="7-Redis的linux环境安装"><a href="#7-Redis的linux环境安装" class="headerlink" title="7. Redis的linux环境安装"></a>7. Redis的linux环境安装</h1><h2 id="7-1-基于Center-OS7安装Redis"><a href="#7-1-基于Center-OS7安装Redis" class="headerlink" title="7.1 基于Center OS7安装Redis"></a>7.1 基于Center OS7安装Redis</h2><ul><li>下载安装包<br>wget <a href="http://download.redis.io/releases/redis-?.?.?.tar.gz">http://download.redis.io/releases/redis-?.?.?.tar.gz</a></li><li>解压<br>tar –xvf 文件名.tar.gz</li><li>编译<br>make</li><li>安装<br>make install [destdir=/目录]</li></ul><h2 id="7-2-Redis服务器端启动"><a href="#7-2-Redis服务器端启动" class="headerlink" title="7.2 Redis服务器端启动"></a>7.2 Redis服务器端启动</h2><ol><li><p>默认：redis-server</p><p>如果想启动多个redis服务器，则需要换端口，那么对应的客户端也需要指定这个端口号</p></li><li><p>redis-server –port xxx(端口号)</p><p>redis-cli –port xxx</p></li><li><p>通过配置文件启动</p><ul><li><p>cp redis-6379.conf redis-6380.conf  [复制配置文件]</p></li><li><p>修改新的配置文件的端口号和日志名</p></li><li><p>启动对应端口的配置文件</p><p>redis-server redis-6380.conf</p></li></ul></li></ol><h1 id="8-Redis持久化"><a href="#8-Redis持久化" class="headerlink" title="8. Redis持久化"></a>8. Redis持久化</h1><h2 id="8-1持久化简介"><a href="#8-1持久化简介" class="headerlink" title="8.1持久化简介"></a>8.1持久化简介</h2><p><strong>什么是持久化：</strong></p><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p><p><strong>为什么要进行持久化：</strong></p><p>防止数据的意外丢失，确保数据安全性</p><p><strong>持久化过程保存什么：</strong></p><ul><li><p> 将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据</p></li><li><p>将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程</p><p><img src="D:\Typo_stroimg\permenent.png" alt="image-20211213213812521"></p></li></ul><h2 id="8-2-RDB"><a href="#8-2-RDB" class="headerlink" title="8.2 RDB"></a>8.2 RDB</h2><h3 id="8-2-1RDB启动方式-——-save指令"><a href="#8-2-1RDB启动方式-——-save指令" class="headerlink" title="8.2.1RDB启动方式 —— save指令"></a>8.2.1<strong>RDB启动方式 —— save指令</strong></h3><blockquote><p>save</p><p>作用：手动执行一次保存操作</p></blockquote><p>相关配置：</p><p><img src="D:\Typo_stroimg\rdb_1.png" alt="image-20211213214017210"></p><p>save工作原理：</p><p><img src="D:\Typo_stroimg\rdb_2.png" alt="image-20211213214124002"></p><p><strong>注意：save指令的执行会<u>阻塞当前Redis服务器，</u>直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用。</strong></p><h3 id="8-2-2-RDB启动方式-——-bgsave指令"><a href="#8-2-2-RDB启动方式-——-bgsave指令" class="headerlink" title="8.2.2 RDB启动方式 —— bgsave指令"></a>8.2.2 RDB启动方式 —— bgsave指令</h3><blockquote><p>bgsave</p><p>作用：手动启动后台保存操作，但不是立即执行</p></blockquote><p>bgsave工作原理：</p><p><img src="D:\Typo_stroimg\rdb_3.png" alt="image-20211213214351056"></p><p>注意： bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用</p><p>以上两种方式均为手动保存，通过配置文件的方式是自动保存</p><h3 id="8-2-3-RDB启动方式-——save配置"><a href="#8-2-3-RDB启动方式-——save配置" class="headerlink" title="8.2.3 RDB启动方式 ——save配置"></a>8.2.3 RDB启动方式 ——save配置</h3><ul><li><p>配置</p><blockquote><p>save second changes</p></blockquote></li><li><p>作用<br>满足限定时间范围内key的变化数量达到指定数量即进行持久化</p></li><li><p>参数<br>second：监控时间范围<br>changes：监控key的变化量</p></li><li><p>位置<br>在conf文件中进行配置</p></li><li><p>范例</p><blockquote><p>save 900 1<br>save 300 10<br>save 60 10000</p></blockquote><p>注意：save配置启动后执行的是bgsave操作</p><p>RDB三种启动方式对比</p><p><img src="D:\Typo_stroimg\rdb_4.png" alt="image-20211213215111676"></p></li></ul><h3 id="8-2-4-总结"><a href="#8-2-4-总结" class="headerlink" title="8.2.4 总结"></a>8.2.4 总结</h3><p><strong>优点：</strong></p><ul><li> RDB是一个紧凑压缩的二进制文件，存储效率较高</li><li>RDB内部存储的是redis在某个时间点的<strong>数据快照</strong>，非常适合用于数据备份，全量复制等场景</li><li>RDB<strong>恢复数据</strong>的速度要比AOF<strong>快</strong>很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li></ul><p><strong>缺点：</strong></p><ul><li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li><li> bgsave指令每次运行要执行<strong>fork操作创建子进程</strong>，要牺牲掉一些性能</li><li> Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现<strong>各版本</strong>服务之间数据格式<strong>无法兼容现象</strong></li></ul><h2 id="8-3-AOF"><a href="#8-3-AOF" class="headerlink" title="8.3 AOF"></a>8.3 AOF</h2><h2 id="8-3-1-AOF概念"><a href="#8-3-1-AOF概念" class="headerlink" title="8.3.1 AOF概念"></a>8.3.1 AOF概念</h2><ul><li>AOF(append only file)持久化：以<strong>独立日志</strong>的方式记录每次写<strong>命令</strong>，重启时再重新执行AOF文件中命令<br>达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</li><li>AOF的主要作用是解决了<strong>数据持久化的实时性</strong>，目前已经是Redis持久化的主流方式</li></ul><h3 id="8-3-2-AOF写数据三种策略-appendfsync"><a href="#8-3-2-AOF写数据三种策略-appendfsync" class="headerlink" title="8.3.2 AOF写数据三种策略(appendfsync)"></a>8.3.2 AOF写数据三种策略(appendfsync)</h3><ul><li>always(每次）<br>每次写入操作均同步到AOF文件中，数据零误差，性能较低</li><li>everysec（每秒）<br>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高<br>在系统突然宕机的情况下丢失1秒内的数据</li><li>no（系统控制）<br>由操作系统控制每次同步到AOF文件的周期，整体过程不可控</li></ul><h3 id="8-3-3-AOF功能开启"><a href="#8-3-3-AOF功能开启" class="headerlink" title="8.3.3 AOF功能开启"></a>8.3.3 AOF功能开启</h3><ul><li><p>配置</p><blockquote><p>appendonly yes|no</p></blockquote></li><li><p>作用<br>是否开启AOF持久化功能，默认为不开启状态</p></li><li><p>配置</p><blockquote><p>appendfsync always|everysec|no</p></blockquote></li><li><p>作用<br>AOF写数据策略</p></li></ul><h3 id="8-3-4-AOF重写"><a href="#8-3-4-AOF重写" class="headerlink" title="8.3.4 AOF重写"></a>8.3.4 AOF重写</h3><p><strong>作用：</strong></p><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><p><strong>重写规则：</strong></p><ul><li>进程内已超时的数据不再写入文件</li><li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<pre><code>  如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</code></pre></li><li>对同一数据的多条写命令合并为一条命令<pre><code> 如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c。为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</code></pre></li></ul><p><strong>重写方式：</strong></p><ul><li><p>手动重写</p><blockquote><p>bgrewriteaof</p></blockquote></li><li><p> 自动重写</p></li></ul><blockquote><p>auto-aof-rewrite-min-size size<br>auto-aof-rewrite-percentage percentage</p></blockquote><p><strong>工作原理：</strong></p><p><img src="D:\Typo_stroimg\aof_1.png" alt="image-20211213220205677"></p><p><strong>工作流程：</strong></p><p>待落实</p><h3 id="8-4-RDB-VS-AOF"><a href="#8-4-RDB-VS-AOF" class="headerlink" title="8.4 RDB VS AOF"></a>8.4 RDB VS AOF</h3><p><img src="D:\Typo_stroimg\aof_2.png" alt="image-20211213220447003"></p><ul><li><p>对数据非常敏感，建议使用默认的AOF持久化方案</p><ul><li><p>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出<br>现问题时，最多丢失0-1秒内的数据。</p></li><li><p>注意：由于AOF文件存储体积较大，且恢复速度较慢</p></li></ul></li><li><p>数据呈现阶段有效性，建议使用RDB持久化方案</p><ul><li><p>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段<br>点数据恢复通常采用RDB方案</p></li><li><p>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：</p></li></ul></li><li><p>综合比对</p><ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF</li><li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li><li>灾难恢复选用RDB</li><li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learn</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
