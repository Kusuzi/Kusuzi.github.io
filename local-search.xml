<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySql</title>
    <link href="/2021/12/25/MySql/"/>
    <url>/2021/12/25/MySql/</url>
    
    <content type="html"><![CDATA[<p>本视频是按照<a href="https://www.bilibili.com/video/BV12b411K7Zu?from=search&seid=14241557604549366754&spm_id_from=333.337.0.0">尚硅谷</a>的相关教程所做的笔记😋。</p><h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><p>​    1.持久化数据到本地<br>​    2.可以实现结构化查询，方便管理<br>​    </p><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><p>​    1、DB：数据库，保存一组有组织的数据的容器<br>​    2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据<br>​    3、SQL:结构化查询语言，用于和DBMS通信的语言</p><h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><p>​    1、将数据放到表中，表再放到库中<br>​    2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。<br>​    3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。<br>​    4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”<br>​    5、表中的数据是按行存储的，每一行类似于java中的“对象”。</p><h2 id="一、MySQL产品的介绍和安装"><a href="#一、MySQL产品的介绍和安装" class="headerlink" title="一、MySQL产品的介绍和安装"></a>一、MySQL产品的介绍和安装</h2><h3 id="1-1-MySQL服务的启动和停止"><a href="#1-1-MySQL服务的启动和停止" class="headerlink" title="1.1 MySQL服务的启动和停止"></a>1.1 MySQL服务的启动和停止</h3><ul><li>方式一：计算机——右击管理——服务</li><li>方式二：通过管理员身份运行<br>​    net start 服务名（启动服务）<br>​    net stop 服务名（停止服务）</li></ul><h3 id="1-2-MySQL服务的登录和退出"><a href="#1-2-MySQL服务的登录和退出" class="headerlink" title="1.2 MySQL服务的登录和退出"></a>1.2 MySQL服务的登录和退出</h3><ul><li><p>方式一：通过mysql自带的客户端</p><pre><code>只限于root用户</code></pre></li><li><p>方式二：通过windows自带的客户端</p><pre><code>登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码</code></pre><p>  退出：exit或ctrl+C</p></li></ul><h3 id="1-3-MySQL的常见命令"><a href="#1-3-MySQL的常见命令" class="headerlink" title="1.3 MySQL的常见命令"></a>1.3 MySQL的常见命令</h3><pre><code>1.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名(    列名 列类型,    列名 列类型，    。。。);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V</code></pre><h3 id="1-4MySQL的语法规范"><a href="#1-4MySQL的语法规范" class="headerlink" title="1.4MySQL的语法规范"></a>1.4MySQL的语法规范</h3><p>​    1.不区分大小写,但建议关键字大写，表名、列名小写<br>​    2.每条命令最好用分号结尾<br>​    3.每条命令根据需要，可以进行缩进 或换行<br>​    4.注释<br>​        单行注释：#注释文字<br>​        单行注释：– 注释文字<br>​        多行注释：/* 注释文字  */<br>​        </p><h3 id="1-5-SQL的语言分类"><a href="#1-5-SQL的语言分类" class="headerlink" title="1.5 SQL的语言分类"></a>1.5 SQL的语言分类</h3><pre><code>DQL（Data Query Language）：数据查询语言    select DML(Data Manipulate Language):数据操作语言    insert 、update、deleteDDL（Data Define Languge）：数据定义语言    create、drop、alterTCL（Transaction Control Language）：事务控制语言    commit、rollback</code></pre><h2 id="二、DQL语言的学习"><a href="#二、DQL语言的学习" class="headerlink" title="二、DQL语言的学习"></a>二、DQL语言的学习</h2><h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><p>​    语法：<br>​    <em>SELECT 要查询的东西</em><br><em>​    【FROM 表名】;</em></p><pre><code>类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</code></pre><h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><p>​    条件查询：根据条件过滤原始表的数据，查询到想要的数据<br><em>​    语法：</em><br><em>​    select</em><br><em>​        要查询的字段|表达式|常量值|函数</em><br><em>​    from</em><br><em>​        表</em><br><em>​    where</em><br><em>​        条件 ;</em></p><pre><code>分类：一、条件表达式    示例：salary&gt;10000    条件运算符：    &gt; &lt; &gt;= &lt;= = != &lt;&gt;二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符：    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false    or(||)：两个条件只要有一个成立，结果为true，否则为false    not(!)：如果条件成立，则not后为false，否则为true三、模糊查询示例：last_name like &#39;a%&#39;</code></pre><h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：select    要查询的东西from    表where     条件order by 排序的字段|表达式|函数|别名 【asc|desc】</code></pre><h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><pre><code>一、单行函数1、字符函数    concat拼接    substr截取子串    upper转换成大写    lower转换成小写    trim去前后指定的空格和字符    ltrim去左边空格    rtrim去右边空格    replace替换    lpad左填充    rpad右填充    instr返回子串第一次出现的索引    length 获取字节个数2、数学函数    round 四舍五入    rand 随机数    floor向下取整    ceil向上取整    mod取余    truncate截断3、日期函数    now当前系统日期+时间    curdate当前系统日期    curtime当前系统时间    str_to_date 将字符转换成日期    date_format将日期转换成字符4、流程控制函数    if 处理双分支    case语句 处理多分支        情况1：处理等值判断        情况2：处理条件判断    5、其他函数    version版本    database当前库    user当前连接用户</code></pre><p>​    </p><p>二、分组函数</p><pre><code>    sum 求和    max 最大值    min 最小值    avg 平均值    count 计数    特点：    1、以上五个分组函数都忽略null值，除了count(*)    2、sum和avg一般用于处理数值型        max、min、count可以处理任何数据类型    3、都可以搭配distinct使用，用于统计去重后的结果    4、count的参数可以支持：        字段、*、常量值，一般放1       建议使用 count(*)</code></pre><h3 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h3><pre><code>语法：select 查询的字段，分组函数from 表group by 分组的字段特点：1、可以按单个字段分组2、和分组函数一同查询的字段最好是分组后的字段3、分组筛选               针对的表         位置                关键字分组前筛选：        原始表        group by的前面        where分组后筛选：    分组后的结果集     group by的后面     having4、可以按多个字段分组，字段之间用逗号隔开5、可以支持排序6、having后可以支持别名</code></pre><h3 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h3><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件</code></pre><p>一、传统模式下的连接 ：等值连接——非等值连接</p><pre><code>1.等值连接的结果 = 多个表的交集2.n表连接，至少需要n-1个连接条件3.多个表不分主次，没有顺序要求4.一般为表起别名，提高阅读性和性能</code></pre><p>二、sql99语法：通过<strong>join</strong>关键字实现连接</p><pre><code>含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on  连接条件【inner|left outer|right outer|cross】join 表3 on  连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</code></pre><p>​<br>三、自连接</p><p>案例：查询员工名和直接上级的名称</p><p>sql99</p><pre><code>SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.`manager_id`=m.`employee_id`;</code></pre><p>sql92</p><pre><code>SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`;</code></pre><h3 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h3><p>含义：</p><pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询</code></pre><p>特点：</p><pre><code>1、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询    结果集只有一行    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;=     非法使用子查询的情况：    a、子查询的结果为一组值    b、子查询的结果为空    ② 多行子查询    结果集有多行    一般搭配多行操作符使用：any、all、in、not in    in： 属于子查询结果中的任意一个就行    any和all往往可以用其他查询代替</code></pre><h3 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h3><p>应用场景：</p><pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</code></pre><p>语法：</p><pre><code>select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数;</code></pre><p>特点：</p><pre><code>1.起始条目索引从0开始2.limit子句放在查询语句的最后3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage假如:每页显示条目数sizePerPage要显示的页数 page</code></pre><h3 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h3><p>引入：<br>    union 联合、合并</p><p>语法：</p><pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】</code></pre><p>特点：</p><pre><code>1、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型几乎相同3、union代表去重，union all代表不去重</code></pre><h2 id="三、DML语言"><a href="#三、DML语言" class="headerlink" title="三、DML语言"></a>三、DML语言</h2><h3 id="3-1-插入"><a href="#3-1-插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h3><p>语法：<br>    insert into 表名(字段名，…)<br>    values(值1，…);</p><p>特点：</p><pre><code>1、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</code></pre><h3 id="3-2-修改"><a href="#3-2-修改" class="headerlink" title="3.2 修改"></a>3.2 修改</h3><p>修改单表语法：</p><pre><code>update 表名 set 字段=新值,字段=新值【where 条件】</code></pre><p>修改多表语法：</p><pre><code>update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件</code></pre><h3 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h3><ul><li>方式1：delete语句 </li></ul><pre><code>单表的删除： ★delete from 表名 【where 筛选条件】多表的删除：delete 别名1，别名2from 表1 别名1，表2 别名2where 连接条件and 筛选条件;</code></pre><ul><li>方式2：truncate语句</li></ul><pre><code>truncate table 表名</code></pre><ul><li><p>两种方式的区别【面试题】    </p><p>#1.truncate不能加where条件，而delete可以加where条件</p><p>#2.truncate的效率高一丢丢</p><p>#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始<br>#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始</p><p>#4.truncate删除不能回滚，delete删除可以回滚</p></li></ul><h2 id="四、DDL语句"><a href="#四、DDL语句" class="headerlink" title="四、DDL语句"></a>四、DDL语句</h2><h3 id="4-1-库的管理"><a href="#4-1-库的管理" class="headerlink" title="4.1 库的管理"></a>4.1 库的管理</h3><pre><code>一、创建库create database 库名二、删除库drop database 库名</code></pre><h3 id="4-2-表的管理："><a href="#4-2-表的管理：" class="headerlink" title="4.2 表的管理："></a>4.2 表的管理：</h3><h4 id="4-2-1-创建表"><a href="#4-2-1-创建表" class="headerlink" title="4.2.1. 创建表"></a>4.2.1. 创建表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS stuinfo(<br>stuId INT,<br>stuName VARCHAR(20),<br>gender CHAR,<br>bornDate DATETIME<br>);<br>DESC studentinfo;<br></code></pre></td></tr></table></figure><p>​    </p><h4 id="4-2-2-修改表-alter"><a href="#4-2-2-修改表-alter" class="headerlink" title="4.2.2.修改表 alter"></a>4.2.2.修改表 alter</h4><pre><code>语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;</code></pre><h5 id="①修改字段名"><a href="#①修改字段名" class="headerlink" title="①修改字段名"></a>①修改字段名</h5><pre><code>ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;</code></pre><h5 id="②修改表名"><a href="#②修改表名" class="headerlink" title="②修改表名"></a>②修改表名</h5><pre><code>ALTER TABLE stuinfo RENAME [TO]  studentinfo;</code></pre><h5 id="③修改字段类型和列级约束"><a href="#③修改字段类型和列级约束" class="headerlink" title="③修改字段类型和列级约束"></a>③修改字段类型和列级约束</h5><pre><code>ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;    </code></pre><h5 id="④添加字段"><a href="#④添加字段" class="headerlink" title="④添加字段"></a>④添加字段</h5><pre><code>ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;</code></pre><h5 id="⑤删除字段"><a href="#⑤删除字段" class="headerlink" title="⑤删除字段"></a>⑤删除字段</h5><pre><code>ALTER TABLE studentinfo DROP COLUMN email;</code></pre><h4 id="4-2-3-删除表"><a href="#4-2-3-删除表" class="headerlink" title="4.2.3.删除表"></a>4.2.3.删除表</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> [<span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span>] 表名;<br></code></pre></td></tr></table></figure><h2 id="五、常见数据类型"><a href="#五、常见数据类型" class="headerlink" title="五、常见数据类型"></a>五、常见数据类型</h2><pre><code>整型：    小数：    浮点型    定点型字符型：日期型：Blob类型：</code></pre><h2 id="六、常见约束"><a href="#六、常见约束" class="headerlink" title="六、常见约束"></a>六、常见约束</h2><pre><code>NOT NULLDEFAULTUNIQUECHECKPRIMARY KEYFOREIGN KEY</code></pre><h2 id="七、数据库事务"><a href="#七、数据库事务" class="headerlink" title="七、数据库事务"></a>七、数据库事务</h2><p>含义</p><p>​    通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</p><h3 id="7-1-特点"><a href="#7-1-特点" class="headerlink" title="7.1 特点"></a>7.1 特点</h3><p>原子性：要么都执行，要么都回滚<br>一致性：保证数据的状态操作前和操作后保持一致<br>隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰<br>持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</p><h3 id="7-2-相关步骤："><a href="#7-2-相关步骤：" class="headerlink" title="7.2 相关步骤："></a>7.2 相关步骤：</h3><pre><code>1、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务</code></pre><h3 id="7-3-事务的分类："><a href="#7-3-事务的分类：" class="headerlink" title="7.3 事务的分类："></a>7.3 事务的分类：</h3><p>隐式事务，没有明显的开启和结束事务的标志</p><pre><code>比如insert、update、delete语句本身就是一个事务</code></pre><p>显式事务，具有明显的开启和结束事务的标志</p><pre><code>    1、开启事务    取消自动提交事务的功能        2、编写事务的一组逻辑操作单元（多条sql语句）    insert    update    delete        3、提交事务或回滚事务</code></pre><h3 id="7-4-使用到的关键字"><a href="#7-4-使用到的关键字" class="headerlink" title="7.4 使用到的关键字"></a>7.4 使用到的关键字</h3><pre><code>set autocommit=0;start transaction;commit;rollback;savepoint  断点commit to 断点rollback to 断点</code></pre><h3 id="7-5-事务的隔离级别"><a href="#7-5-事务的隔离级别" class="headerlink" title="7.5 事务的隔离级别:"></a>7.5 事务的隔离级别:</h3><p>事务并发问题如何发生？</p><pre><code>当多个事务同时操作同一个数据库的相同数据时</code></pre><p>事务的并发问题有哪些？</p><pre><code>脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</code></pre><p>如何避免事务的并发问题？</p><pre><code>通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读</code></pre><p>设置隔离级别：</p><pre><code>set session|global  transaction isolation level 隔离级别名;</code></pre><p>查看隔离级别：</p><pre><code>select @@tx_isolation;</code></pre><h2 id="八、视图"><a href="#八、视图" class="headerlink" title="八、视图"></a>八、视图</h2><p>含义：理解成一张虚拟的表</p><h3 id="8-1-视图和表的区别："><a href="#8-1-视图和表的区别：" class="headerlink" title="8.1 视图和表的区别："></a>8.1 视图和表的区别：</h3><table><thead><tr><th></th><th>使用方式</th><th>占用物理空间</th></tr></thead><tbody><tr><td>视图</td><td>完全相同</td><td>不占用，仅仅保存的是sql逻辑</td></tr><tr><td>表</td><td>完全相同</td><td>占用</td></tr></tbody></table><h3 id="8-2-视图的好处："><a href="#8-2-视图的好处：" class="headerlink" title="8.2 视图的好处："></a>8.2 视图的好处：</h3><pre><code>1、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性</code></pre><h3 id="8-3-视图的创建"><a href="#8-3-视图的创建" class="headerlink" title="8.3 视图的创建"></a>8.3 视图的创建</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span>  视图名<br><span class="hljs-keyword">AS</span><br>查询语句;<br></code></pre></td></tr></table></figure><h3 id="8-4-视图的增删改查"><a href="#8-4-视图的增删改查" class="headerlink" title="8.4 视图的增删改查"></a>8.4 视图的增删改查</h3><p>​    1、查看视图的数据 ★</p><pre><code>SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name=&#39;Partners&#39;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);3、修改视图的数据UPDATE my_v4 SET last_name =&#39;梦姑&#39; WHERE last_name=&#39;虚竹&#39;;4、删除视图的数据DELETE FROM my_v4;</code></pre><h3 id="8-5-某些视图不能更新"><a href="#8-5-某些视图不能更新" class="headerlink" title="8.5 某些视图不能更新"></a>8.5 某些视图不能更新</h3><p>​    包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all<br>​    常量视图<br>​    Select中包含子查询<br>​    join<br>​    from一个不能更新的视图<br>​    where子句的子查询引用了from子句中的表</p><h3 id="8-6-视图逻辑的更新"><a href="#8-6-视图逻辑的更新" class="headerlink" title="8.6 视图逻辑的更新"></a>8.6 视图逻辑的更新</h3><pre><code>#方式一：CREATE OR REPLACE VIEW test_v7ASSELECT last_name FROM employeesWHERE employee_id&gt;100;#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7;</code></pre><h3 id="8-7-视图的删除"><a href="#8-7-视图的删除" class="headerlink" title="8.7 视图的删除"></a>8.7 视图的删除</h3><pre><code>DROP VIEW test_v1,test_v2,test_v3;</code></pre><h3 id="8-8-视图结构的查看"><a href="#8-8-视图结构的查看" class="headerlink" title="8.8 视图结构的查看"></a>8.8 视图结构的查看</h3><pre><code>DESC test_v7;SHOW CREATE VIEW test_v7;</code></pre><h2 id="九、存储过程"><a href="#九、存储过程" class="headerlink" title="九、存储过程"></a>九、存储过程</h2><p>含义：一组经过预先编译的sql语句的集合<br>好处：</p><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率3、减少了传输次数</code></pre><p>分类：</p><pre><code>1、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个</code></pre><h3 id="9-1-创建存储过程"><a href="#9-1-创建存储过程" class="headerlink" title="9.1 创建存储过程"></a>9.1 创建存储过程</h3><p>语法：</p><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)begin    存储过程体end</code></pre><p>类似于方法：</p><pre><code>修饰符 返回类型 方法名(参数类型 参数名,...)&#123;    方法体;&#125;</code></pre><p>注意</p><pre><code>1、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)BEGIN    sql语句1;    sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出</code></pre><h3 id="9-2-调用存储过程"><a href="#9-2-调用存储过程" class="headerlink" title="9.2 调用存储过程"></a>9.2 调用存储过程</h3><p>​    call 存储过程名(实参列表)</p><h2 id="十、函数"><a href="#十、函数" class="headerlink" title="十、函数"></a>十、函数</h2><h3 id="10-1-创建函数"><a href="#10-1-创建函数" class="headerlink" title="10.1 创建函数"></a>10.1 创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p><pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN    函数体END</code></pre><h3 id="10-2-调用函数"><a href="#10-2-调用函数" class="headerlink" title="10.2  调用函数"></a>10.2  调用函数</h3><p>​    SELECT 函数名（实参列表）</p><h3 id="10-3-函数和存储过程的区别"><a href="#10-3-函数和存储过程的区别" class="headerlink" title="10.3 函数和存储过程的区别"></a>10.3 函数和存储过程的区别</h3><table><thead><tr><th></th><th>关键字</th><th>调用语法</th><th>返回值</th><th>应用场景</th></tr></thead><tbody><tr><td>函数</td><td>FUNCTION</td><td>SELECT</td><td>函数()    只能是一个</td><td>一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个</td></tr><tr><td>存储过程</td><td>PROCEDURE</td><td>CALL</td><td>存储过程()    可以有0个或多个</td><td>一般用于更新</td></tr></tbody></table><h2 id="十一、流程控制结构"><a href="#十一、流程控制结构" class="headerlink" title="十一、流程控制结构"></a>十一、流程控制结构</h2><h3 id="11-1-系统变量"><a href="#11-1-系统变量" class="headerlink" title="11.1 系统变量"></a>11.1 系统变量</h3><p>一、全局变量</p><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p><pre><code>查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0;</code></pre><p>二、会话变量</p><p>作用域：针对于当前会话（连接）有效</p><pre><code>查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation=&#39;read-uncommitted&#39;;SET SESSION tx_isolation=&#39;read-committed&#39;;</code></pre><h3 id="11-2-自定义变量"><a href="#11-2-自定义变量" class="headerlink" title="11.2 自定义变量"></a>11.2 自定义变量</h3><h4 id="11-2-1-用户变量"><a href="#11-2-1-用户变量" class="headerlink" title="11.2.1 用户变量"></a>11.2.1 用户变量</h4><p>声明并初始化：</p><pre><code>SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select @变量名;</code></pre><h4 id="11-2-2-局部变量"><a href="#11-2-2-局部变量" class="headerlink" title="11.2.2 局部变量"></a>11.2.2 局部变量</h4><p>声明：</p><pre><code>declare 变量名 类型 【default 值】;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select 变量名</code></pre><h4 id="12-2-3-二者的区别："><a href="#12-2-3-二者的区别：" class="headerlink" title="12.2.3 二者的区别："></a>12.2.3 二者的区别：</h4><pre><code>        作用域            定义位置        语法</code></pre><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p><h2 id="十二、分支"><a href="#十二、分支" class="headerlink" title="十二、分支"></a>十二、分支</h2><h3 id="12-1-if函数"><a href="#12-1-if函数" class="headerlink" title="12.1 if函数"></a>12.1 if函数</h3><p>​    语法：if(条件，值1，值2)<br>​    特点：可以用在任何位置</p><h3 id="12-2-case语句"><a href="#12-2-case语句" class="headerlink" title="12.2 case语句"></a>12.2 case语句</h3><p>语法：</p><pre><code>情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre><p>特点：<br>    可以用在任何位置</p><h3 id="12-3-if-elseif语句"><a href="#12-3-if-elseif语句" class="headerlink" title="12.3 if elseif语句"></a>12.3 if elseif语句</h3><p>语法：</p><pre><code>if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if;</code></pre><p>特点：<br>    只能用在<strong>begin end</strong>中！！！！！！！！！！！！！！！</p><p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p><h3 id="12-4-循环"><a href="#12-4-循环" class="headerlink" title="12.4 循环"></a>12.4 循环</h3><p>语法：</p><pre><code>【标签：】WHILE 循环条件  DO    循环体END WHILE 【标签】;</code></pre><p>特点：</p><pre><code>只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2021/12/15/SpringBoot/"/>
    <url>/2021/12/15/SpringBoot/</url>
    
    <content type="html"><![CDATA[<p>本篇文章是根据<a href="https://www.bilibili.com/video/BV15b4y1a7yG?p=1">黑马程序员SpringBoot2全套视频教程</a>出品的视频，学习所做的笔记🐰。</p><p>视频发布时间：2021.10.26</p><h1 id="1-快速上手SpringBoot"><a href="#1-快速上手SpringBoot" class="headerlink" title="1. 快速上手SpringBoot"></a>1. 快速上手SpringBoot</h1><h2 id="1-1-SpringBoot入门程序开发"><a href="#1-1-SpringBoot入门程序开发" class="headerlink" title="1.1 SpringBoot入门程序开发"></a>1.1 SpringBoot入门程序开发</h2><ul><li>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来<font color='red'>简化</font>Spring应用的<font color='red'>初始搭建</font>以及<font color='red'>开发过程</font></li></ul><h3 id="1-1-1-S2pringBoot入门程序"><a href="#1-1-1-S2pringBoot入门程序" class="headerlink" title="1.1.1 S2pringBoot入门程序"></a>1.1.1 S2pringBoot入门程序</h3><p>（1）创建新模块，选择Spring Initializr，并配置模块相关基础信息</p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Springboot/image.png" alt="image" style="zoom: 67%;" /><p>2）选择当前模块需要使用的技术集</p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Springboot/image.6vp7mfozcus0.png" alt="image" style="zoom: 80%;" /><p>3）开发控制器类</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Springboot/image.75euv8hmxiw0.png" alt="image"></p><p>4）运行自动生成的Application类</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Springboot/image.613hxfau7o00.png" alt="image"></p><h3 id="1-1-2-入门案列"><a href="#1-1-2-入门案列" class="headerlink" title="1.1.2 入门案列"></a>1.1.2 入门案列</h3><ul><li><p>最简SpringBoot程序所包含的基础文件</p><ul><li>pom.xml文件</li><li> Application类</li></ul></li><li><p>Spring程序与SpringBoot程序对比</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Springboot/image.1rlayaopp3y8.png" alt="image"></p><p>注意：基于idea开发SpringBoot程序需要确保<strong>联网</strong>且能够加载到程序框架结构</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Springboot/image.42687dug5hk0.png" alt="image"></p></li></ul><h3 id="1-1-3-隐藏指定文件-文件夹"><a href="#1-1-3-隐藏指定文件-文件夹" class="headerlink" title="1.1.3 隐藏指定文件/文件夹"></a>1.1.3 隐藏指定文件/文件夹</h3><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Springboot/image.5l74k9ymyp40.png" alt="image"></p><p>Idea中隐藏指定文件或指定类型文件</p><ul><li>Setting → File Types → Ignored Files and Folders</li><li> 输入要隐藏的文件名，支持*号通配符 </li><li>回车确认添加</li></ul><h2 id="1-2-SpringBoot简介"><a href="#1-2-SpringBoot简介" class="headerlink" title="1.2 SpringBoot简介"></a>1.2 SpringBoot简介</h2><p>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程</p><ul><li>Spring程序缺点<br> 依赖设置繁琐<br> 配置繁琐</li><li>SpringBoot程序优点<br> 起步依赖（简化依赖配置）<br> 自动配置（简化常用工程相关配置）<br> 辅助功能（内置服务器，……</li></ul><ol><li><p>简化依赖配置</p><p><strong>parent</strong></p><ul><li><p>开发SpringBoot程序要继承spring-boot-starter-parent</p></li><li><p>spring-boot-starter-parent中定义了若干个依赖管理</p></li><li><p>继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突</p></li><li><p>继承parent的形式也可以采用引入依赖的形式实现效果</p></li><li><p>定义了若干个坐标版本号（依赖管理，而非依赖），以达到<font color='red'>减少依赖冲突</font>的目的</p></li><li><p>spring-boot-starter-parent各版本间存在着诸多坐标版本不同</p></li></ul><p><strong>starter</strong></p><ul><li>  SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标，以达到<font color='red'>减少依赖配置</font>的目的</li><li>开发SpringBoot程序需要导入坐标时通常导入对应的starter</li><li>每个不同的starter根据功能不同，通常包含多个依赖坐标</li><li>使用starter可以实现快速配置的效果，达到简化配置的目的</li></ul><p><strong>实际开发</strong></p><ul><li>使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V</li><li>如发生坐标错误，再指定Version（要小心版本冲突）</li></ul></li><li><p>自动配置</p><p><strong>引导类</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quickstart01Application</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        SpringApplication.run(Quickstart01Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目</li><li>SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean</li></ul></li><li><p>辅助功能</p><p><strong>内嵌tomcat</strong></p><ol><li>内嵌Tomcat服务器是SpringBoot辅助功能之一</li><li>内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理</li><li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Springboot/image.19yep7mcer4w.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Springboot/image.5e7uh7t7quo0.png" alt="image"></p></li></ol><ul><li><p>Jetty比Tomcat更轻量级，可扩展性更强（相较于Tomcat），谷歌应用引擎（GAE）已经全面切换为Jetty</p><p>内置服务器的比较：</p><table><thead><tr><th>tomcat(默认)</th><th align="left">apache出品，粉丝多，应用面广，负载了若干较重的组件</th></tr></thead><tbody><tr><td>jetty</td><td align="left">更轻量级，负载性能远不及tomcat</td></tr><tr><td>undertow</td><td align="left">负载性能勉强跑赢tomcat</td></tr></tbody></table></li></ul><h1 id="2-基础配置"><a href="#2-基础配置" class="headerlink" title="2.  基础配置"></a>2.  基础配置</h1><h3 id="2-1-属性配置"><a href="#2-1-属性配置" class="headerlink" title="2.1 属性配置"></a>2.1 属性配置</h3><p>配置位置：SpringBoot默认配置文件application.properties</p><ul><li><p>修改服务器端口</p><blockquote><p>server.port=80</p></blockquote></li><li><p>关闭运行日志图标（banner）</p><blockquote><p>spring.main.banner-mode=off</p></blockquote></li><li><p>设置日志相关</p><blockquote><p>logging.level.root=debug</p></blockquote></li></ul><p>SpringBoot内置属性查询<br> <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties</a><br> 官方文档中参考文档第一项：Application Properties</p><h3 id="2-2-配置文件分类"><a href="#2-2-配置文件分类" class="headerlink" title="2.2  配置文件分类"></a>2.2  配置文件分类</h3><ul><li>SpringBoot提供了多种属性配置方式</li></ul><blockquote><p>properties  yml    yaml</p></blockquote><ul><li><p> properties（传统格式/默认格式）</p></li><li><p> yml（主流格式）</p></li><li><p> yaml</p></li><li><p>SpringBoot配置文件加载顺序</p><pre><code>  application.properties &gt; application.yml &gt; application.yaml</code></pre></li><li><p>配置文件间的加载优先级</p><ul><li>properties（最高）</li><li>yml</li><li>yaml（最低）</li></ul></li></ul><ol start="2"><li>不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留</li></ol><h3 id="2-3-yaml文件"><a href="#2-3-yaml文件" class="headerlink" title="2.3  yaml文件"></a>2.3  yaml文件</h3><ul><li><p>YAML文件扩展名</p><ul><li>.yml（主流）</li><li> .yaml</li></ul></li><li><p>yaml语法规则</p><ul><li>大小写敏感</li></ul></li><li><p>属性层级关系使用多行描述，每行结尾使用冒号结束</p><ul><li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</li></ul></li><li><p>属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</p><ul><li># 表示注释</li></ul></li><li><p> 核心规则：数据前面要加空格与冒号隔开</p></li><li><p> <img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Springboot/yaml.png" alt="yaml"></p></li></ul><h3 id="2-4-yaml数据读取"><a href="#2-4-yaml数据读取" class="headerlink" title="2.4  yaml数据读取"></a>2.4  yaml数据读取</h3><p>方式一：</p><p><strong>使用局部变量</strong></p><ul><li><p>使用@Value读取单个数据，属性名引用方式：${一级属性名.二级属性名……}</p></li><li><p>如果数据存在多层级，依次书写层级名称即可</p><p>缺点：需要定义多个变量</p></li></ul><p>方式二</p><p>​    <strong>封装全部数据到Environment对象</strong></p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Springboot/env.png" alt="env" style="zoom: 50%;" /><ol><li>使用Environment对象封装全部配置信息</li><li>使用@Autowired自动装配数据到Environment对象中</li></ol><p>方式三</p><p><strong>自定义对象封装指定数据</strong></p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Springboot/dataclass.png" alt="dataclass" style="zoom:50%;" /><p>注意：</p><ul><li>自定义对象中的变量名需要和配置文件中的变量名一致</li><li>封装类需要定义为Spring管理的bean，否则无法进行属性注入</li><li>使用@ConfigurationProperties注解绑定配置信息到封装类中</li></ul><h1 id="3-整合第三方技术"><a href="#3-整合第三方技术" class="headerlink" title="3. 整合第三方技术"></a>3. 整合第三方技术</h1><h2 id="3-1-整合junit"><a href="#3-1-整合junit" class="headerlink" title="3.1 整合junit"></a>3.1 整合junit</h2><p>直接创建一个最简单的spring Initializer模块即可</p><ol><li>导入测试对应的starter</li><li>测试类使用@SpringBootTest修饰</li><li>使用自动装配的形式添加要测试的对象</li></ol><p>对SpringBootTest的解释：</p><ul><li><p>类型：测试类注解</p></li><li><p> 位置：测试类定义上方</p></li><li><p> 作用：设置JUnit加载的SpringBoot启动类</p></li><li><p>范例：  </p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JunitInterApplicationTests</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><font color='red'>注意</font>：如果测试类在SpringBoot启动类的包或子包中，可以省略启动类的设置，也就是省略classes的设定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = Springboot05JUnitApplication.class)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot07JUnitApplicationTests</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><ol><li> 测试类如果存在于引导类所在包或子包中无需指定引导类</li><li>测试类如果不存在于引导类所在的包或子包中需要通过<font color='cornflowerblue'>classes</font>属性指定引导类</li></ol><h2 id="3-2-整合MyBatis"><a href="#3-2-整合MyBatis" class="headerlink" title="3.2 整合MyBatis"></a>3.2 整合MyBatis</h2><h2 id="3-3-整合MyBatis-Plus"><a href="#3-3-整合MyBatis-Plus" class="headerlink" title="3.3. 整合MyBatis-Plus"></a>3.3. 整合MyBatis-Plus</h2><h2 id="3-4-整合Druid"><a href="#3-4-整合Druid" class="headerlink" title="3.4 整合Druid"></a>3.4 整合Druid</h2>]]></content>
    
    
    <categories>
      
      <category>Spring系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2021/12/10/Redis/"/>
    <url>/2021/12/10/Redis/</url>
    
    <content type="html"><![CDATA[<p> 本篇文章是根据<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">黑马程序员</a>的视频，学习所做的笔记🦊。</p><h1 id="1-Redis的简单介绍"><a href="#1-Redis的简单介绍" class="headerlink" title="1. Redis的简单介绍"></a>1. Redis的简单介绍</h1><p><strong>概念：</strong>Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的<em>高性能键值对（key-value）数据库。</em></p><p><strong>类型</strong>：非关系型数据库（Nosql）</p><p><strong>特征：</strong></p><ul><li>可扩容，可伸缩</li><li>大数据量下高性能</li><li>灵活的数据模型</li><li>高可用</li></ul><p><strong>关键词：</strong>单线程、高性能、多数据类型、持久化</p><h1 id="2-Redis的应用"><a href="#2-Redis的应用" class="headerlink" title="2. Redis的应用"></a>2. Redis的应用</h1><ul><li>为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等</li><li>任务队列，如秒杀、抢购、购票排队等</li><li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设<br>备信号等 </li><li>时效性信息控制，如验证码控制、投票控制等</li><li>分布式数据共享，如分布式集群架构中的 session 分离</li><li>消息队列</li><li>分布式锁</li></ul><h1 id="3-Redis的五大数据类型"><a href="#3-Redis的五大数据类型" class="headerlink" title="3. Redis的五大数据类型"></a>3. Redis的五大数据类型</h1><p>​        <strong>redis                             java</strong></p><ul><li><p>String                          String</p></li><li><p>hash                          HashMap</p></li><li><p>list                             LinkedList</p></li><li><p>set                              HashSet</p></li><li><p>sortedset(zset)          TreeSet</p><p>数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串</p></li></ul><h1 id="4-Redis对不同数据类型的常见命令"><a href="#4-Redis对不同数据类型的常见命令" class="headerlink" title="4. Redis对不同数据类型的常见命令"></a>4. Redis对不同数据类型的常见命令</h1><h2 id="4-1-String"><a href="#4-1-String" class="headerlink" title="4.1 String"></a>4.1 String</h2><ul><li> 存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li><li> 存储数据的格式：一个存储空间保存一个数据</li><li>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</li></ul><ol><li><strong>基本命令：</strong></li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">set <span class="hljs-built_in">key</span> value                                         [添加/修改单条数据]<br><span class="hljs-built_in">get</span> <span class="hljs-built_in">key</span>                                               [获取单条数据]<br><span class="hljs-built_in">del</span> <span class="hljs-built_in">key</span>                                               [删除数据]<br>setex <span class="hljs-built_in">key</span>  <span class="hljs-built_in">second</span> value                               [设置<span class="hljs-built_in">key</span>的生命周期]<br>incr <span class="hljs-built_in">key</span>                                              [为某一个<span class="hljs-built_in">key</span>做自增操作，++<span class="hljs-built_in">key</span>]<br>decr <span class="hljs-built_in">key</span> <br></code></pre></td></tr></table></figure><ol start="2"><li><strong>其他命令:</strong></li></ol><blockquote><p><strong>mset</strong> key1 value1 key2 value2 … 【添加/修改多条数据】</p><p><strong>mget</strong> key1 key2 …                                【获取多条数据】</p><p><strong>strlen</strong> key                                    【获取数据字符个数（字符串长度）】</p><p><strong>append</strong> key value       [ 追加信息到原始信息后部（如果原始信息存在就追加，否则新建）]</p></blockquote><p>set 和 mset之间的选择问题：如果查询数据量较多时，可以选择mset来节约服务器与redis之间的往返时间</p><blockquote><p><strong>incrby</strong>  key   increment                         【为某一个key加上increment，但只能是整数】</p><p><strong>incrbyfloat</strong> key increment                  【为某一个key加上increment，可以是小数】</p><p><strong>decrby</strong> key increment</p></blockquote><p>string 作为数值操作:</p><ul><li><p>string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算。</p></li><li><p>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发<br>带来的数据影响。</p></li><li><p>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。<br>9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</p><p>string 类型数据操作的注意事项</p><blockquote><p> <strong>数据操作不成功的反馈与数据正常操作之间的差异</strong></p><p>① 表示运行结果是否成功</p><p>(integer) 0 → false 失败<br> (integer) 1 → true  成功<br>② 表示运行结果值<br> (integer) 3 → 3 3个<br>(integer) 1 → 1 1个<br> <strong>数据未获取到</strong><br>（nil）等同于null<br><strong>数据最大存储量</strong><br>512MB<br> <strong>数值计算最大范围（java中的long的最大值）</strong><br>9223372036854775807</p></blockquote></li></ul><p><strong>业务场景</strong>：主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/string_01.png" alt="string_01"></p><h2 id="4-2-hash"><a href="#4-2-hash" class="headerlink" title="4.2 hash"></a>4.2 hash</h2><ul><li>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</li><li>需要的存储结构：一个存储空间保存多个键值对数据</li><li>hash类型：底层使用哈希表结构实现数据存储</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/hash_01.png" alt="hash_01"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">hset key field value         [添加/修改数据]<br>hget key field               [获取数据]<br>hgetall key                  <br>hdel key field1 [field2]     [删除数据]      <br></code></pre></td></tr></table></figure><ol start="2"><li><strong>其他命令</strong> </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">hmset key field1 value1 field2 value2 … <br>hmget key field1 field2 … <br>hlen key                    [获取哈希表中field字段的数量]<br>hexists key field           [获取哈希表中是否存在指定的字段]<br>    <br>hkeys key                   [ 获取哈希表中所有的字段名或字段值]<br>hvals key<br>hincrby key field increment [设置指定字段的数值数据增加指定范围的值]<br>hincrbyfloat key field increment<br></code></pre></td></tr></table></figure><p>hash 类型数据操作的注意事项 </p><ul><li><p>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，<br>对应的值为（nil）</p></li><li><p>hash 类型数据操作的注意事项</p></li><li><p>每个 hash 可以存储 2 32 - 1 个键值对</p></li><li><p>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存<br>储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用</p></li><li><p>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问<br>瓶颈</p></li></ul><p>对比：string存储对象（json）<strong>VS</strong> hash存储对象</p><p>String的好处：将对象的内容组装为一个整体，更倾向于<em>读取</em> </p><p>hash的好处：将对象的内容分成不同的field，更倾向于<em>更新</em></p><h2 id="4-3-list"><a href="#4-3-list" class="headerlink" title="4.3 list"></a>4.3 list</h2><ul><li> 数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</li><li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</li><li>list类型：保存多个数据，底层使用<strong>双向链表</strong>存储结构实现</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/list_1.jpg" alt="list_1"></p><ol><li><p><strong>基本命令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">lpush key value1 [value2] ……        【 添加/修改数据】<br>rpush key value1 [value2] ……<br>  <br>lrange key start stop                【获取数据】<br>lindex key index<br>llen key <br>    <br>lpop key                            【获取并移除数据】<br>rpop key<br></code></pre></td></tr></table></figure></li><li><p><strong>其他命令</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">blpop key1 [key2] <span class="hljs-keyword">timeout</span>           [ 规定时间内获取并移除数据]<br>brpop key1 [key2] <span class="hljs-keyword">timeout</span><br>brpoplpush source destination <span class="hljs-keyword">timeout</span><br><br>lrem key <span class="hljs-built_in">count</span> value                [移除指定数据,<span class="hljs-built_in">count</span>表示为：移掉多少个]<br></code></pre></td></tr></table></figure><p>相当于阻塞，如果list中没有数据则阻塞，在规定的时间内有数据就输出并移除</p></li><li><p><strong>注意事项</strong></p><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2 32 - 1 个元素 (4294967295)。</li><li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作</li><li>获取全部数据操作结束索引设置为-1</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</li></ul></li><li><p><strong>业务场景</strong></p><ul><li>twitter、新浪微博、腾讯微博中个人用户的<strong>关注列表</strong>需要按照用户的关注顺序进行展示，粉丝列表需要将最<br>近关注的粉丝列在前面</li><li>新闻、资讯类网站如何将最新的新闻或资讯按照发生的<strong>时间顺序展示？</strong></li></ul></li></ol><h2 id="4-4-set"><a href="#4-4-set" class="headerlink" title="4.4 set"></a>4.4 set</h2><ul><li><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率</p></li><li><p>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</p></li><li><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/set1.png" alt="set1"></p></li></ul><ol><li>基本命令</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sadd</span> key member<span class="hljs-number">1</span><span class="hljs-meta"> [member2]        [添加数据]</span><br><span class="hljs-attribute">smembers</span> key                     <span class="hljs-meta"> [获取全部数据]</span><br><span class="hljs-attribute">srem</span> key member<span class="hljs-number">1</span><span class="hljs-meta"> [member2]        [删除数据]</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>其他命令</strong></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">scard key                         <span class="hljs-selector-attr">[获取集合数据总量]</span><br>sismember key member              <span class="hljs-selector-attr">[判断集合中是否包含指定数据]</span><br>srandmember key <span class="hljs-selector-attr">[count]</span>           <span class="hljs-selector-attr">[随机获取集合中指定数量的数据]</span><br>spop key <span class="hljs-selector-attr">[count]</span>                  <span class="hljs-selector-attr">[随机获取集合中的某个数据并将该数据移出集合]</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sinter</span> key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]               [求两个集合的交、并、差集]</span><br><span class="hljs-attribute">sunion</span> key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]</span><br><span class="hljs-attribute">sdiff</span> key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]</span><br><br><span class="hljs-attribute">sinterstore</span> destination key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]  [求两个集合的交、并、差集并存储到指定集合中]</span><br><span class="hljs-attribute">sunionstore</span> destination key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]</span><br><span class="hljs-attribute">sdiffstore</span> destination key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]</span><br><br><span class="hljs-attribute">smove</span> source destination member     <span class="hljs-meta"> [将指定数据从原始集合中移动到目标集合中]</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>注意事项</strong></li></ol><ul><li> set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份</li><li> set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间【set中的value类似于hash中的field】</li></ul><ol start="4"><li><strong>业务场景</strong></li></ol><ul><li>redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，<br>大V推荐等</li><li>新浪微博为了增加用户热度，提高用户留存性，需要微博用户在关注更多的人，以此获得更多的信息或热门<br>话题，如何提高用户关注他人的总量？</li><li>共同好友、共同关注等</li><li>redis 应用于同类型数据的快速去重</li><li>设置白名单或者黑名单</li></ul><h2 id="4-5-sorteds-set"><a href="#4-5-sorteds-set" class="headerlink" title="4.5 sorteds_set"></a>4.5 sorteds_set</h2><ul><li><p>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p></li><li><p>需要的存储结构：新的存储模型，可以保存可排序的数据</p></li><li><p>sorted_set类型：在set的存储结构基础上添加<strong>可排序字段</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sorted_set.png" alt="sorted_set"></p></li></ul><ol><li><p><strong>基本命令</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">zadd</span> <span class="hljs-selector-tag">key</span> <span class="hljs-selector-tag">score1</span> <span class="hljs-selector-tag">member1</span> <span class="hljs-selector-attr">[score2 member2]</span>           <span class="hljs-selector-attr">[添加数据]</span>  <br><br><span class="hljs-selector-tag">zrange</span> <span class="hljs-selector-tag">key</span> <span class="hljs-selector-tag">start</span> <span class="hljs-selector-tag">stop</span> <span class="hljs-selector-attr">[WITHSCORES]</span>                 <span class="hljs-selector-attr">[获取全部数据]</span>(升序)<br><span class="hljs-selector-tag">zrevrange</span> <span class="hljs-selector-tag">key</span> <span class="hljs-selector-tag">start</span> <span class="hljs-selector-tag">stop</span> <span class="hljs-selector-attr">[WITHSCORES]</span>               (降序)<br><br><span class="hljs-selector-tag">zrem</span> <span class="hljs-selector-tag">key</span> <span class="hljs-selector-tag">member</span> <span class="hljs-selector-attr">[member ...]</span>                       <span class="hljs-selector-attr">[删除数据]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>其他命令</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xquery">zrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> min</span><span class="hljs-built_in"> max</span> [WITHSCORES] [LIMIT]         [按条件获取数据]<br>zrevrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> max</span><span class="hljs-built_in"> min</span> [WITHSCORES]<br><br>zremrangebyrank<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> stop                         [条件删除数据]<br>zremrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> min</span><span class="hljs-built_in"> max</span><br><br></code></pre></td></tr></table></figure><ul><li> min与max用于限定搜索查询的条件</li><li> start与stop用于限定查询范围，作用于索引，表示开始和结束索引</li><li>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zcard <span class="hljs-built_in">key</span>                                              [获取集合数据总量]           <br>zcount <span class="hljs-built_in">key</span> <span class="hljs-built_in">min</span> <span class="hljs-built_in">max</span>                                     [集合交、并操作]<br><br>zrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>                                      [获取数据对应的索引（排名）]<br>zrevrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span><br>   <br>zscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>                                      score值获取与修改<br>zincrby <span class="hljs-built_in">key</span> increment <span class="hljs-built_in">member</span><br></code></pre></td></tr></table></figure></li><li><p><strong>注意事项</strong></p><ul><li> score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个<strong>双精度的double值</strong>，基于双精度浮点数的特征，可能会丢失精度，使用时<br>候要慎重</li><li>sorted_set 底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反<br>复覆盖，保留最后一次修改的结果</li></ul></li><li><p><strong>业务场景</strong></p><ul><li>票选广东十大杰出青年，各类综艺选秀海选投票</li><li>各类资源网站TOP10（电影，歌曲，文档，电商，游戏等）</li><li>聊天室活跃度统计</li><li>游戏好友亲密度</li><li>redis 应用于即时任务/消息队列执行管理(对于高优先级的任务要保障对其优先处理)</li></ul></li></ol><h2 id="4-6-数据类型实践案例"><a href="#4-6-数据类型实践案例" class="headerlink" title="4.6 数据类型实践案例"></a>4.6 数据类型实践案例</h2><p>业务场景：</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sorted_set2.png" alt="sorted_set2"></p><p><a href="https://www.bilibili.com/video/BV1CJ411m7Gc?p=32">代码实现</a></p><h1 id="5-Redis-通用指令"><a href="#5-Redis-通用指令" class="headerlink" title="5. Redis 通用指令"></a>5. Redis 通用指令</h1><h2 id="5-1-key-通用指令"><a href="#5-1-key-通用指令" class="headerlink" title="5.1 key 通用指令"></a>5.1 key 通用指令</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs maxima">keys *       [查看所有的<span class="hljs-built_in">key</span>]<br><span class="hljs-built_in">del</span> <span class="hljs-built_in">key</span>      [删除指定的<span class="hljs-built_in">key</span>]<br>exists <span class="hljs-built_in">key</span>   [获取<span class="hljs-built_in">key</span>是否存在]<br>type <span class="hljs-built_in">key</span>     [获取<span class="hljs-built_in">key</span>的类型]<br>expire <span class="hljs-built_in">key</span> seconds [设置指定<span class="hljs-built_in">key</span>的有效期]<br>ttl <span class="hljs-built_in">key</span>       [获取指定<span class="hljs-built_in">key</span>的有效时间]<br>pttl <span class="hljs-built_in">key</span><br><span class="hljs-built_in">rename</span> <span class="hljs-built_in">key</span> newkey   [为<span class="hljs-built_in">key</span>改名]<br>renamenx <span class="hljs-built_in">key</span> newkey<br></code></pre></td></tr></table></figure><h2 id="5-2-数据库通用指令"><a href="#5-2-数据库通用指令" class="headerlink" title="5.2 数据库通用指令"></a>5.2 数据库通用指令</h2><ul><li><p>redis为每个服务提供有16个数据库，编号从0到15</p></li><li><p>每个数据库之间的数据相互独立</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">select</span> <span class="hljs-meta">index</span>   [切换数据库]<br><span class="hljs-keyword">quit</span><br><span class="hljs-keyword"></span>move <span class="hljs-meta">key</span> db    [数据移动]<br>dbsize         [数据清除]<br>flushdb<br>flushall<br></code></pre></td></tr></table></figure></li></ul><h1 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6. Jedis"></a>6. Jedis</h1><h2 id="6-1-准备工作"><a href="#6-1-准备工作" class="headerlink" title="6.1 准备工作"></a>6.1 准备工作</h2><ul><li><p>导入jedis坐标</p><blockquote><dependency><groupId>redis.clients</groupId><artifactId>jedis</artifactId><version>2.9.0</version></dependency></blockquote></li><li><p>连接jedis</p><blockquote><p>Jedis jedis = new Jedis(“localhost”, 6379);</p></blockquote></li><li><p>操作jedis</p></li><li><p>关闭jedis连接</p><blockquote><p>jedis.close();</p></blockquote></li></ul><h2 id="6-2-案例"><a href="#6-2-案例" class="headerlink" title="6.2 案例"></a>6.2 案例</h2><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/jedis_1.jpg" alt="jedis_1"></p><p><a href="https://www.bilibili.com/video/BV1CJ411m7Gc?p=44">代码演示</a></p><p>主程序：</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/jedis_02.jpg" alt="jedis_02"></p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/jedis_03.jpg" alt="jedis_03"  /><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/jedis_04.jpg" alt="jedis_04"></p><h2 id="6-3-jedis简易工具类开发"><a href="#6-3-jedis简易工具类开发" class="headerlink" title="6.3 jedis简易工具类开发"></a>6.3 jedis简易工具类开发</h2><p> JedisPool：Jedis提供的连接池技术</p><p>需要的三个内容：</p><p>poolConfig:连接池配置对象<br>host:redis服务地址<br>port:redis服务端口号</p><blockquote><p>//设置poolConfig</p><p>poolConfig = new JedisPoolConfig();<br>poolConfig.setMaxTotal(maxTotal);<br>poolConfig.setMaxIdle(maxIdle);</p><p>// 设置JedisPool</p><p>jedisPool = new JedisPool(poolConfig,host,port);</p></blockquote><h1 id="7-Redis的linux环境安装"><a href="#7-Redis的linux环境安装" class="headerlink" title="7. Redis的linux环境安装"></a>7. Redis的linux环境安装</h1><h2 id="7-1-基于Center-OS7安装Redis"><a href="#7-1-基于Center-OS7安装Redis" class="headerlink" title="7.1 基于Center OS7安装Redis"></a>7.1 基于Center OS7安装Redis</h2><ul><li>下载安装包<br>wget <a href="http://download.redis.io/releases/redis-?.?.?.tar.gz">http://download.redis.io/releases/redis-?.?.?.tar.gz</a></li><li>解压<br>tar –xvf 文件名.tar.gz</li><li>编译<br>make</li><li>安装<br>make install [destdir=/目录]</li></ul><h2 id="7-2-Redis服务器端启动"><a href="#7-2-Redis服务器端启动" class="headerlink" title="7.2 Redis服务器端启动"></a>7.2 Redis服务器端启动</h2><ol><li><p>默认：redis-server</p><p>如果想启动多个redis服务器，则需要换端口，那么对应的客户端也需要指定这个端口号</p></li><li><p>redis-server –port xxx(端口号)</p><p>redis-cli –port xxx</p></li><li><p>通过配置文件启动</p><ul><li><p>cp redis-6379.conf redis-6380.conf  [复制配置文件]</p></li><li><p>修改新的配置文件的端口号和日志名</p></li><li><p>启动对应端口的配置文件</p><p>redis-server redis-6380.conf</p></li></ul></li></ol><h1 id="8-Redis持久化"><a href="#8-Redis持久化" class="headerlink" title="8. Redis持久化"></a>8. Redis持久化</h1><h2 id="8-1持久化简介"><a href="#8-1持久化简介" class="headerlink" title="8.1持久化简介"></a>8.1持久化简介</h2><p><strong>什么是持久化：</strong></p><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p><p><strong>为什么要进行持久化：</strong></p><p>防止数据的意外丢失，确保数据安全性</p><p><strong>持久化过程保存什么：</strong></p><ul><li><p> 将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据</p></li><li><p>将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/permenent.png" alt="permenent"></p></li></ul><h2 id="8-2-RDB"><a href="#8-2-RDB" class="headerlink" title="8.2 RDB"></a>8.2 RDB</h2><h3 id="8-2-1RDB启动方式-——-save指令"><a href="#8-2-1RDB启动方式-——-save指令" class="headerlink" title="8.2.1RDB启动方式 —— save指令"></a>8.2.1<strong>RDB启动方式 —— save指令</strong></h3><blockquote><p>save</p><p>作用：手动执行一次保存操作</p></blockquote><p>相关配置：</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/rdb_1.png" alt="rdb_1"></p><p>save工作原理：</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/rdb_2.png" alt="rdb_2"></p><p><strong>注意：save指令的执行会<u>阻塞当前Redis服务器，</u>直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用。</strong></p><h3 id="8-2-2-RDB启动方式-——-bgsave指令"><a href="#8-2-2-RDB启动方式-——-bgsave指令" class="headerlink" title="8.2.2 RDB启动方式 —— bgsave指令"></a>8.2.2 RDB启动方式 —— bgsave指令</h3><blockquote><p>bgsave</p><p>作用：手动启动后台保存操作，但不是立即执行</p></blockquote><p>bgsave工作原理：</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/rdb_3.png" alt="rdb_3"></p><p>注意： bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用</p><p>以上两种方式均为手动保存，通过配置文件的方式是自动保存</p><h3 id="8-2-3-RDB启动方式-——save配置"><a href="#8-2-3-RDB启动方式-——save配置" class="headerlink" title="8.2.3 RDB启动方式 ——save配置"></a>8.2.3 RDB启动方式 ——save配置</h3><ul><li><p>配置</p><blockquote><p>save second changes</p></blockquote></li><li><p>作用<br>满足限定时间范围内key的变化数量达到指定数量即进行持久化</p></li><li><p>参数<br>second：监控时间范围<br>changes：监控key的变化量</p></li><li><p>位置<br>在conf文件中进行配置</p></li><li><p>范例</p><blockquote><p>save 900 1<br>save 300 10<br>save 60 10000</p></blockquote><p>注意：save配置启动后执行的是bgsave操作</p><p>RDB三种启动方式对比</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/rdb_4.png" alt="rdb_4"></p></li></ul><h3 id="8-2-4-总结"><a href="#8-2-4-总结" class="headerlink" title="8.2.4 总结"></a>8.2.4 总结</h3><p><strong>优点：</strong></p><ul><li> RDB是一个紧凑压缩的二进制文件，存储效率较高</li><li>RDB内部存储的是redis在某个时间点的<strong>数据快照</strong>，非常适合用于数据备份，全量复制等场景</li><li>RDB<strong>恢复数据</strong>的速度要比AOF<strong>快</strong>很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li></ul><p><strong>缺点：</strong></p><ul><li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li><li> bgsave指令每次运行要执行<strong>fork操作创建子进程</strong>，要牺牲掉一些性能</li><li> Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现<strong>各版本</strong>服务之间数据格式<strong>无法兼容现象</strong></li></ul><h2 id="8-3-AOF"><a href="#8-3-AOF" class="headerlink" title="8.3 AOF"></a>8.3 AOF</h2><h3 id="8-3-1-AOF概念"><a href="#8-3-1-AOF概念" class="headerlink" title="8.3.1 AOF概念"></a>8.3.1 AOF概念</h3><ul><li>AOF(append only file)持久化：以<strong>独立日志</strong>的方式记录每次写<strong>命令</strong>，重启时再重新执行AOF文件中命令<br>达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</li><li>AOF的主要作用是解决了<strong>数据持久化的实时性</strong>，目前已经是Redis持久化的主流方式</li></ul><h3 id="8-3-2-AOF写数据三种策略-appendfsync"><a href="#8-3-2-AOF写数据三种策略-appendfsync" class="headerlink" title="8.3.2 AOF写数据三种策略(appendfsync)"></a>8.3.2 AOF写数据三种策略(appendfsync)</h3><ul><li>always(每次）<br>每次写入操作均同步到AOF文件中，数据零误差，性能较低</li><li>everysec（每秒）<br>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高<br>在系统突然宕机的情况下丢失1秒内的数据</li><li>no（系统控制）<br>由操作系统控制每次同步到AOF文件的周期，整体过程不可控</li></ul><h3 id="8-3-3-AOF功能开启"><a href="#8-3-3-AOF功能开启" class="headerlink" title="8.3.3 AOF功能开启"></a>8.3.3 AOF功能开启</h3><ul><li><p>配置</p><blockquote><p>appendonly yes|no</p></blockquote></li><li><p>作用<br>是否开启AOF持久化功能，默认为不开启状态</p></li><li><p>配置</p><blockquote><p>appendfsync always|everysec|no</p></blockquote></li><li><p>作用<br>AOF写数据策略</p></li></ul><h3 id="8-3-4-AOF重写"><a href="#8-3-4-AOF重写" class="headerlink" title="8.3.4 AOF重写"></a>8.3.4 AOF重写</h3><p><strong>作用：</strong></p><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><p><strong>重写规则：</strong></p><ul><li>进程内已超时的数据不再写入文件</li><li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<pre><code>  如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</code></pre></li><li>对同一数据的多条写命令合并为一条命令<pre><code> 如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c。为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</code></pre></li></ul><p><strong>重写方式：</strong></p><ul><li><p>手动重写</p><blockquote><p>bgrewriteaof</p></blockquote></li><li><p> 自动重写</p></li></ul><blockquote><p>auto-aof-rewrite-min-size size<br>auto-aof-rewrite-percentage percentage</p></blockquote><p><strong>工作原理：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/aof_1.png" alt="aof_1"></p><p><strong>工作流程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/aof-process.png" alt="aof-process"></p><p>AOF重写流程：</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/aof-rewrite.png" alt="aof-rewrite"></p><h3 id="8-4-RDB-VS-AOF"><a href="#8-4-RDB-VS-AOF" class="headerlink" title="8.4 RDB VS AOF"></a>8.4 RDB VS AOF</h3><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/aof_2.png" alt="aof_2"></p><ul><li><p>对数据非常敏感，建议使用默认的AOF持久化方案</p><ul><li><p>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出<br>现问题时，最多丢失0-1秒内的数据。</p></li><li><p>注意：由于AOF文件存储体积较大，且恢复速度较慢</p></li></ul></li><li><p>数据呈现阶段有效性，建议使用RDB持久化方案</p><ul><li><p>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段<br>点数据恢复通常采用RDB方案</p></li><li><p>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：</p></li></ul></li><li><p>综合比对</p><ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF</li><li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li><li>灾难恢复选用RDB</li><li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量</li></ul></li></ul><h1 id="9-Redis事务"><a href="#9-Redis事务" class="headerlink" title="9. Redis事务"></a>9. Redis事务</h1><h2 id="9-1-事务简介"><a href="#9-1-事务简介" class="headerlink" title="9.1 事务简介"></a>9.1 事务简介</h2><p>redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性<br>按照添加顺序依次执行，中间不会被打断或者干扰。一个队列中，一次性、顺序性、排他性的执行一系列命令。</p><h2 id="9-2-事务基本操作"><a href="#9-2-事务基本操作" class="headerlink" title="9.2 事务基本操作"></a>9.2 事务基本操作</h2><h3 id="9-2-1-基本命令"><a href="#9-2-1-基本命令" class="headerlink" title="9.2.1 基本命令"></a>9.2.1 基本命令</h3><ul><li> 开启事务</li></ul><blockquote><p>multi</p></blockquote><ul><li><p>作用</p><p>设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</p></li><li><p>执行事务</p><blockquote><p>exec</p></blockquote></li><li><p>作用</p><p>设定事务的结束位置，同时执行事务。与multi成对出现，成对使用</p><p><strong><font color='red'>注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</font></strong></p></li><li><p> 取消事务</p></li></ul><blockquote><p>discard</p></blockquote><ul><li><p>作用</p><p>终止当前事务的定义，发生在multi之后，exec之前</p><h3 id="9-2-2-事务的工作流程"><a href="#9-2-2-事务的工作流程" class="headerlink" title="9.2.2 事务的工作流程"></a>9.2.2 事务的工作流程</h3><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/tx_1.png" alt="tx_1"></p></li></ul><h3 id="9-2-3-事务的注意事项"><a href="#9-2-3-事务的注意事项" class="headerlink" title="9.2.3 事务的注意事项"></a>9.2.3 事务的注意事项</h3><ul><li>定义事务的过程中，<strong>命令格式****输入</strong>错误怎么办？<ul><li>语法错误<pre><code>指命令书写格式有误</code></pre></li><li>处理结果<pre><code> 如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。</code></pre></li></ul></li><li>定义事务的过程中，<strong>命令执行</strong>出现错误怎么办？<ul><li>运行错误<pre><code>指命令格式正确，但是无法正确的执行。例如对list进行incr操作</code></pre></li><li>处理结果<br>  能够正确运行的命令会执行，运行错误的命令不会被执行[错的和正确地各执行各的]</li></ul></li></ul><p><font color='red'>注意：已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</font></p><h3 id="9-2-4-手动进行事务回滚"><a href="#9-2-4-手动进行事务回滚" class="headerlink" title="9.2.4 手动进行事务回滚"></a>9.2.4 手动进行事务回滚</h3><ul><li>记录操作过程中被影响的数据之前的状态<pre><code>    单数据：string      多数据：hash、list、set、zset</code></pre></li><li>设置指令恢复所有的被修改的项<pre><code>  单数据：直接set（注意周边属性，例如时效）  多数据：修改对应值或整体克隆复制</code></pre></li></ul><h2 id="9-3-锁"><a href="#9-3-锁" class="headerlink" title="9.3 锁"></a>9.3 锁</h2><p><strong>业务分析1:</strong></p><p> 多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作<br> 在操作之前锁定要操作的数据，一旦发生变化，终止当前操作</p><p><strong>解决方案1：</strong></p><ul><li> 对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</li></ul><blockquote><p>watch key1 [key2……]     [只要被监控的发生了变化，则后续的事务都不会被执行，哪怕是没有被监控的对象]</p></blockquote><ul><li><p>取消对所有 key 的监视</p><blockquote><p>unwatch</p></blockquote></li></ul><p><strong>业务分析2:【超卖问题】</strong></p><p> 使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据<br> 虽然redis是单线程的，但是多个客户端对同一数据同时进行操作时，如何避免不被同时修改？</p><p><strong>解决方案2：</strong></p><ul><li> 使用 setnx 设置一个公共锁</li></ul><blockquote><p>setnx lock-key value</p></blockquote><p>  利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功<br>           对于返回设置成功的，拥有控制权，进行下一步的具体业务操作<br>          对于返回设置失败的，不具有控制权，排队或等待<br>  操作完毕通过del操作释放锁</p><p>  注意：上述解决方案是一种设计概念，依赖规范保障，具有风险性</p><p><strong>业务分析3:</strong></p><p> 由于锁操作由用户控制加锁解锁，必定会存在<font color='cornflowerblue'>加锁后未解锁</font>的风险<br> 需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案</p><p><strong>解决方案3：</strong></p><ul><li> 使用 expire 为锁key添加时间限定，到时不释放，放弃锁</li></ul><blockquote><p>expire lock-key second<br>pexpire lock-key milliseconds</p></blockquote><p>  由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。<br>        例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。<br>        测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时<br>        锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%<br>        如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</p><h1 id="10-Redis删除策略"><a href="#10-Redis删除策略" class="headerlink" title="10. Redis删除策略"></a>10. Redis删除策略</h1><h2 id="10-1-过期数据"><a href="#10-1-过期数据" class="headerlink" title="10.1 过期数据"></a>10.1 过期数据</h2><p>Redis中的数据特征</p><ul><li>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态<ul><li>XX ：具有时效性的数据</li><li> -1 ：永久有效的数据</li><li> -2 ：已经过期的数据 或 被删除的数据 或 未定义的数据</li></ul></li></ul><h2 id="10-2-数据删除策略"><a href="#10-2-数据删除策略" class="headerlink" title="10.2 数据删除策略"></a>10.2 数据删除策略</h2><ol><li><p>定时删除</p></li><li><p>惰性删除</p></li><li><p>定期删除</p><p><strong>时效性数据的存储结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/del_1.png" alt="del_1"></p></li></ol><h3 id="10-2-1-定时删除"><a href="#10-2-1-定时删除" class="headerlink" title="10.2.1 定时删除"></a>10.2.1 定时删除</h3><ul><li> 创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</li><li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用</li><li>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li><li>总结：用处理器性能换取存储空间 （拿时间换空间）</li></ul><h3 id="10-2-2-惰性删除"><a href="#10-2-2-惰性删除" class="headerlink" title="10.2.2 惰性删除"></a>10.2.2 惰性删除</h3><ul><li>数据到达过期时间，不做处理。等下次访问该数据时<ul><li>如果未过期，返回数据</li><li>发现已过期，删除，返回不存在</li></ul></li><li>优点：节约CPU性能，发现必须删除的时候才删除</li><li> 缺点：内存压力很大，出现长期占用内存的数据</li><li>总结：用存储空间换取处理器性能（拿空间换时间)<br>会用到expireIfNeeded()函数</li></ul><h3 id="10-2-3-定期删除"><a href="#10-2-3-定期删除" class="headerlink" title="10.2.3 定期删除"></a>10.2.3 定期删除</h3><p><strong>定时轮询，对每个库进行轮询</strong></p><ul><li><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p></li><li><p>每秒钟执行server.hz次<strong>serverCron()</strong>——&gt;<strong>databasesCron()</strong>——–&gt;<strong>activeExpireCycle()</strong></p></li><li><p> <font color='red'>activeExpireCycle()</font>对每个expires[*]逐一进行检测，每次执行250ms/server.hz</p></li><li><p>*对某个expires[*]检测时，随机挑选W个key检测</p></li><li><p>如果key超时，删除key</p></li><li><p>如果一轮中删除的key的数量&gt;W*25%，循环该过程</p></li><li><p>如果一轮中删除的key的数量≤W<em>25%，检查下一个expires[</em>]，0-15循环</p></li><li><p>W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值</p></li><li><p> 参数current_db用于记录<font color='red'>activeExpireCycle() </font>进入哪个expires[*] 执行</p></li><li><p>如果<font color='red'>activeExpireCycle()</font>执行时间到期，下次从current_db继续向下执行</p></li></ul><p>总结：</p><ol><li>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</li><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li><li>总结：周期性抽查存储空间（随机抽查，重点抽查）</li></ol><h3 id="10-2-4-删除策略比对"><a href="#10-2-4-删除策略比对" class="headerlink" title="10.2.4 删除策略比对"></a>10.2.4 删除策略比对</h3><table><thead><tr><th>定期删除</th><th>内存定期随机清理</th><th>每秒花费固定的CPU资源维护内存</th><th>随机抽查，重点抽查</th></tr></thead><tbody><tr><td>定时删除</td><td>节约内存，无占用</td><td>不分时段占用CPU资源，频度高</td><td>拿时间换空间</td></tr><tr><td>惰性删除</td><td>内存占用严重</td><td>延时执行，CPU利用率高</td><td>拿空间换时间</td></tr></tbody></table><h2 id="10-3-逐出算法（淘汰算法）"><a href="#10-3-逐出算法（淘汰算法）" class="headerlink" title="10.3 逐出算法（淘汰算法）"></a>10.3 逐出算法（淘汰算法）</h2><p>问题：当新数据进入redis时，如果内存不足怎么办？</p><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用<font color='red'>freeMemoryIfNeeded()</font>检测内存是否充足。如<br>果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据<br>的策略称为逐出算法。</li><li>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所<br>有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</li></ul><h3 id="10-3-1-影响数据逐出的相关配置"><a href="#10-3-1-影响数据逐出的相关配置" class="headerlink" title="10.3.1. 影响数据逐出的相关配置"></a>10.3.1. 影响数据逐出的相关配置</h3><ul><li><p>最大可使用内存</p><blockquote><p>maxmemory</p></blockquote><p>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</p></li><li><p>每次选取待删除数据的个数</p><blockquote><p>maxmemory-samples</p></blockquote><p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p></li><li><p> 删除策略</p></li></ul><blockquote><p>maxmemory-policy</p></blockquote><p>  达到最大内存后的，对被挑选出来的数据进行删除的策略</p><h3 id="10-3-2-逐出算法种类"><a href="#10-3-2-逐出算法种类" class="headerlink" title="10.3.2. 逐出算法种类"></a>10.3.2. 逐出算法种类</h3><ol><li>检测易失数据（可能会过期的数据集server.db[i].expires ）<br>① volatile-lru：挑选最近最少使用的数据淘汰<br>② volatile-lfu：挑选最近使用次数最少的数据淘汰<br>③ volatile-ttl：挑选将要过期的数据淘汰<br>④ volatile-random：任意选择数据淘汰</li><li>检测全库数据（所有数据集server.db[i].dict ）<br>⑤ allkeys-lru：挑选最近最少使用的数据淘汰<br>⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰<br>⑦ allkeys-random：任意选择数据淘汰</li><li>放弃数据驱逐<br>⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</li></ol><p><strong>数据逐出策略配置依据</strong><br> 使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置</p><h1 id="11-主从复制"><a href="#11-主从复制" class="headerlink" title="11. 主从复制"></a>11. 主从复制</h1><h2 id="11-1-主从复制简介"><a href="#11-1-主从复制简介" class="headerlink" title="11.1. 主从复制简介"></a>11.1. 主从复制简介</h2><h3 id="11-1-1-互联网“三高”架构"><a href="#11-1-1-互联网“三高”架构" class="headerlink" title="11.1.1. 互联网“三高”架构"></a>11.1.1. 互联网“三高”架构</h3><ul><li> 高并发</li><li>高性能</li><li> 高可用</li></ul><p><strong>单机redis的风险与问题</strong></p><ul><li>问题1.机器故障<pre><code>      现象：硬盘故障、系统崩溃          本质：数据丢失，很可能对业务造成灾难性打击           结论：基本上会放弃使用redis.</code></pre></li><li>问题2.容量瓶颈<pre><code>    现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存   本质：穷，硬件条件跟不上   结论：放弃使用redis</code></pre></li><li>结论：<pre><code>   为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服   务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续  提供服务，实现Redis的高可用，同时实现数据冗余备份。</code></pre></li></ul><h4 id="11-1-2-多台服务器连接方案"><a href="#11-1-2-多台服务器连接方案" class="headerlink" title="11.1.2. 多台服务器连接方案"></a>11.1.2. 多台服务器连接方案</h4><ul><li><p>提供数据方：master</p><ul><li>主服务器，主节点，主库</li><li>主客户端</li></ul></li><li><p>接收数据方：slave</p><ul><li>从服务器，从节点，从库</li><li>从客户端</li></ul></li><li><p>需要解决的问题：</p><ul><li>数据同步</li></ul></li><li><p>核心工作：</p><ul><li><p>master的数据复制到slave中</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/%E4%B8%BB%E4%BB%8E_01.png" alt="主从_01"></p></li></ul></li></ul><h3 id="11-1-3-主从复制的作用"><a href="#11-1-3-主从复制的作用" class="headerlink" title="11.1.3. 主从复制的作用"></a>11.1.3. 主从复制的作用</h3><p>主从复制即将master中的数据即时、有效的复制到slave中<br>特征：一个master可以拥有多个slave，一个slave只对应一个master</p><p>职责：</p><ul><li><p>master:</p><ul><li>写数据</li><li>执行写操作时，将出现变化的数据自动同步到slave</li><li> 读数据（可忽略）</li></ul></li><li><p>slave:</p><ul><li> 读数据</li><li>写数据（禁止）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/%E9%9B%86%E7%BE%A4.png" alt="集群"></p></li><li><p>读写分离：master写、slave读，提高服务器的读写负载能力</p></li><li><p> 负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</p></li><li><p>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</p></li><li><p>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</p></li><li><p>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</p></li></ul><h2 id="11-2-主从复制工作流程"><a href="#11-2-主从复制工作流程" class="headerlink" title="11.2. 主从复制工作流程"></a>11.2. 主从复制工作流程</h2><p>主从复制过程大体可以分为3个阶段<br> 建立连接阶段（即准备阶段）<br> 数据同步阶段<br> 命令传播阶段</p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/主从流程_01.png" alt="主从流程_01" style="zoom:67%;" /><h3 id="11-2-1-阶段一：建立连接阶段"><a href="#11-2-1-阶段一：建立连接阶段" class="headerlink" title="11.2.1 阶段一：建立连接阶段"></a>11.2.1 阶段一：建立连接阶段</h3><ul><li> 建立slave到master的连接，使master能够识别slave，并保存slave端口号</li></ul><p>步骤1：设置master的地址和端口，客户端保存master信息<br>步骤2：建立socket连接<br>步骤3：发送ping命令（定时器任务）<br>步骤4：身份验证<br>步骤5：发送slave端口信息<br>至此，主从连接成功！<br><strong>状态：</strong><br>slave：保存master的地址与端口<br>master：保存slave的端口<br><strong>总体：</strong><br>之间创建了连接的socket</p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/stage_01.png" alt="stage_01" style="zoom:67%;" /><p>主从连接（slave连接master）：</p><ol><li><p>方式一：客户端发送命令</p><blockquote><p>slaveof <masterip> <masterport>  [从主动连接]</p></blockquote></li><li><p>方式二：启动服务器参数</p><blockquote><p>redis-server -slaveof <masterip> <masterport></p></blockquote></li><li><p>方式三：服务器配置</p><blockquote><p>slaveof <masterip> <masterport>   [在配置文件中配置，启动这个配置文件时，就会有主从结构]</p></blockquote></li></ol><p>主从断开连接:</p><ol><li><p>客户端发送命令</p><blockquote><p>slaveof no one</p><p>attention:   slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</p></blockquote></li></ol><ul><li> 授权访问</li></ul><table><thead><tr><th>1 master客户端发送命令设置密码</th><th>1 slave客户端发送命令设置密码</th></tr></thead><tbody><tr><td>requirepass <password></td><td>auth <password></td></tr><tr><td>2 master配置文件设置密码</td><td>2 slave配置文件设置密码</td></tr><tr><td>config set requirepass <password></td><td>masterauth <password></td></tr><tr><td>config get requirepass</td><td>3 slave启动服务器设置密码</td></tr><tr><td></td><td>redis-server –a <password></td></tr></tbody></table><h3 id="11-2-2-阶段二：数据同步阶段工作流程"><a href="#11-2-2-阶段二：数据同步阶段工作流程" class="headerlink" title="11.2.2 阶段二：数据同步阶段工作流程"></a>11.2.2 阶段二：数据同步阶段工作流程</h3><ul><li>在slave初次连接master后，复制master中的所有数据到slave</li><li> 将slave的数据库状态更新成master当前的数据库状态</li></ul><p>步骤1：请求同步数据<br>步骤2：创建RDB同步数据<br>步骤3：恢复RDB同步数据<br>步骤4：请求部分同步数据<br>步骤5：恢复部分同步数据<br>至此，数据同步工作完成！ </p><p><strong>状态：</strong><br>slave：具有master端全部数据，包含RDB过程接收的数据<br>master：保存slave当前数据同步的位置<br><strong>总体：</strong><br>之间完成了数据克隆</p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/stage_02.png" alt="stage_02" style="zoom:67%;" /><p><strong>数据同步阶段master说明</strong></p><ol><li><p>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</p></li><li><p>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</p></li></ol><blockquote><p>repl-backlog-size 1mb     [master修改复制缓冲区的大小]</p></blockquote><ol start="3"><li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区</li></ol><p><strong>数据同步阶段slave说明</strong></p><ol><li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务</p><blockquote><p>slave-serve-stale-data yes|no</p></blockquote></li><li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p></li><li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</p></li><li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，数据一致性变差，应谨慎选择</p></li></ol><h3 id="11-2-3-命令传播阶段"><a href="#11-2-3-命令传播阶段" class="headerlink" title="11.2.3 命令传播阶段"></a>11.2.3 命令传播阶段</h3><ul><li><p>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的<br>状态，同步的动作称为命令传播</p></li><li><p>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</p></li></ul><p>不同情况发生时，命令传播阶段会采用不同的数据同步方法</p><ul><li> 网络闪断闪连           忽略</li><li>短时间网络中断        部分复制</li><li>长时间网络中断       全量复制</li></ul><p>部分复制的三个核心要素</p><ol><li><p>服务器的运行 id（run id）</p><blockquote><p>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</p><p>作用：运行id被用于在服务器间进行传输，识别身份如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</p><p>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid</p></blockquote></li><li><p> 主服务器的复制积压缓冲区</p></li></ol><blockquote><p>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</p></blockquote><ol start="3"><li><p>主从服务器的复制偏移量</p><blockquote><p>概念：一个数字，描述复制缓冲区中的指令字节位置</p><p>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</p></blockquote></li></ol><p><font color='red'>数据同步+命令传播阶段工作流程</font></p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/stage_23.png" alt="stage_23"></p><h3 id="11-2-4-心跳机制"><a href="#11-2-4-心跳机制" class="headerlink" title="11.2.4 心跳机制"></a>11.2.4 心跳机制</h3><ul><li>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</li><li>master心跳：<ul><li>指令：PING</li><li> 周期：由repl-ping-slave-period决定，默认10秒</li><li> 作用：判断slave是否在线</li><li>查询：INFO replication  获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li></ul></li><li>slave心跳任务<ul><li> 指令：REPLCONF ACK {offset}</li><li> 周期：1秒</li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li><li> 作用2：判断master是否在线</li></ul></li></ul><h1 id="12-哨兵模式"><a href="#12-哨兵模式" class="headerlink" title="12. 哨兵模式"></a>12. 哨兵模式</h1><h2 id="12-1-哨兵简介"><a href="#12-1-哨兵简介" class="headerlink" title="12.1 哨兵简介"></a>12.1 哨兵简介</h2><p>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行<font color='cornflowerblue'>监控</font>，当出现故障时通过投票机制<font color='cornflowerblue'>选择</font>新的master并将所有slave连接到新的master。</p><p><strong>哨兵的作用</strong>    </p><ul><li>监控<ul><li>不断的检查master和slave是否正常运行。</li><li>master存活检测、master与slave运行情况检测</li></ul></li><li>通知（提醒）<ul><li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</li></ul></li><li>自动故障转移<ul><li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li></ul></li></ul><p><font color='cornflowerblue'>注意：</font></p><ul><li>哨兵也是一台redis服务器，只是不提供数据服务</li><li>通常哨兵配置数量为<font color='red'>单数</font></li></ul><h2 id="12-2-启动哨兵模式"><a href="#12-2-启动哨兵模式" class="headerlink" title="12.2 启动哨兵模式"></a>12.2 启动哨兵模式</h2><ul><li><p>配置一拖二的主从结构</p></li><li><p>配置三个哨兵（配置相同，端口不同）<br>参看sentinel.conf</p></li><li><p>启动哨兵</p><blockquote><p>redis-sentinel sentinel- 端口号 .conf</p></blockquote></li></ul><p>配置哨兵</p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sential_config.png" alt="sential_config"></p><h2 id="12-3-哨兵工作原理"><a href="#12-3-哨兵工作原理" class="headerlink" title="12.3 哨兵工作原理"></a>12.3 哨兵工作原理</h2><p> 哨兵在进行主从切换过程中经历三个阶段</p><ul><li>监控</li><li>通知</li><li>故障转移</li></ul><h3 id="12-3-1-监控阶段"><a href="#12-3-1-监控阶段" class="headerlink" title="12.3.1 监控阶段"></a>12.3.1 监控阶段</h3><p>用于同步各个节点的状态信息</p><ul><li><p> 获取各个sentinel的状态（是否在线）</p></li><li><p> 获取master的状态</p></li><li><p>master属性</p></li><li><p>runid</p></li><li><p>role：master</p></li><li><p> 各个slave的详细信息</p></li><li><p>获取所有slave的状态（根据master中的slave信息）</p><ul><li> runid</li><li>role：slave</li><li> master_host、master_port</li><li> offset</li><li> ……</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sential_stage01.png" alt="sential_stage01"  /><h3 id="12-3-2-通知阶段"><a href="#12-3-2-通知阶段" class="headerlink" title="12.3.2 通知阶段"></a>12.3.2 通知阶段</h3><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sential_stage02.png" alt="sential_stage02"></p><h3 id="12-3-3-故障转移阶段"><a href="#12-3-3-故障转移阶段" class="headerlink" title="12.3.3 故障转移阶段"></a>12.3.3 故障转移阶段</h3><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sential_stage03.png" alt="sential_stage03"></p><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/stage032.png" alt="stage032"></p><p>选择了哨兵老大过后，选择相应的slave当选master</p><ul><li>服务器列表中挑选备选master<ul><li> 在线的</li><li>响应快的</li><li> 与原master断开时间短的</li><li>优先原则<ul><li> 优先级</li><li>offset</li><li>runid</li></ul></li></ul></li><li>发送指令（ sentinel ）<ul><li> 向新的master发送slaveof no one</li><li> 向其他slave发送slaveof 新masterIP端口</li></ul></li></ul><h3 id="12-4-总结"><a href="#12-4-总结" class="headerlink" title="12.4 总结"></a>12.4 总结</h3><ul><li> 监控</li><li> 同步信息</li><li>通知<ul><li> 保持联通   【sentinel和sentinel，sentinel和master和 slave】</li></ul></li><li>故障转移<ul><li> 发现问题</li><li>竞选负责人   【选取sentinel来处理故障】</li><li> 优选新master</li><li> 新master上任，其他slave切换master，原master作为slave故障回复后连接</li></ul></li></ul><h1 id="13-Cluster"><a href="#13-Cluster" class="headerlink" title="13. Cluster"></a>13. Cluster</h1><h2 id="13-1-集群简介"><a href="#13-1-集群简介" class="headerlink" title="13.1 集群简介"></a>13.1 集群简介</h2><p>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</p><p><strong>集群作用</strong></p><ul><li><p> 分散单台服务器的访问压力，实现负载均衡</p></li><li><p> 分散单台服务器的存储压力，实现可扩展性</p></li><li><p> 降低单台服务器宕机带来的业务灾难</p></li></ul>  <img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/cluster.png" alt="cluster" style="zoom:67%;" /><h2 id="13-2-redis集群结构设计"><a href="#13-2-redis集群结构设计" class="headerlink" title="13.2 redis集群结构设计"></a>13.2 redis集群结构设计</h2><ol><li>数据存储设计</li></ol><ul><li><p>通过算法设计，计算出key应该保存的位置</p></li><li><p>将所有的存储空间计划切割成16384份，每台主机保存一部分每份代表的是一个存储空间，不是一个key的保存空间</p></li><li><p>将key按照计算出的结果放到对应的存储空间【槽】</p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/slot_cal.png" alt="slot_cal" style="zoom:67%;" /></li></ul><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/slot.png" alt="slot" style="zoom:50%;" /><ol start="2"><li>集群内部通讯设计</li></ol><ul><li><p>各个数据库相互通信，保存各个库中槽的编号数据</p></li><li><p>一次命中，直接返回</p></li><li><p>一次未命中，告知具体位置</p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/cluster_com.png" alt="cluster_com" style="zoom:67%;" /></li></ul><h2 id="13-3-cluster集群结构搭建"><a href="#13-3-cluster集群结构搭建" class="headerlink" title="13.3 cluster集群结构搭建"></a>13.3 cluster集群结构搭建</h2><p><a href="https://www.bilibili.com/video/BV1CJ411m7Gc?p=104&spm_id_from=pageDriver">视频搭建教程</a></p><h1 id="14-企业级解决方案"><a href="#14-企业级解决方案" class="headerlink" title="14. 企业级解决方案"></a>14. 企业级解决方案</h1><h2 id="14-2-缓存预热"><a href="#14-2-缓存预热" class="headerlink" title="14.2 缓存预热"></a>14.2 缓存预热</h2><p><strong>问题</strong>：服务器启动后迅速宕机</p><p><strong>排查：</strong></p><ol><li>请求数量较高</li><li>主从之间数据吞吐量较大，数据同步操作频度较高</li></ol><p><strong>解决方案：</strong></p><p>前置准备工作：</p><ol><li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li><li>利用LRU数据删除策略，构建数据留存队列<br>例如：storm与kafka配合</li></ol><p>准备工作：</p><ol><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li><li>热点数据主从同时预热</li></ol><p>实施：</p><ol><li>使用脚本程序固定触发数据预热过程</li><li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li></ol><p><strong>总结</strong>：缓存预热就是系统启动前，<font color='red'>提前将相关的缓存数据直接加载到缓存系统</font>。避免在用户请求的时候，先查询数据库，然后再将数据缓<br>存的问题！用户直接查询事先被预热的缓存数据！</p><h2 id="14-2-缓存雪崩"><a href="#14-2-缓存雪崩" class="headerlink" title="14.2 缓存雪崩"></a>14.2 缓存雪崩</h2><p><strong>问题</strong>：缓存雪崩描述的就是这样⼀个简单的场景：<strong>缓存在同⼀时间大面积的失效，后⾯的请求都直接落到了数据库上，</strong>造成数据库短时间内承受⼤量请求。 这就好⽐雪崩⼀样，摧枯拉朽之势，数据库的压⼒可想⽽知，可能直接就被这么多请求弄宕机了。</p><p><strong>解决方案：</strong></p><p>针对 Redis 服务不可⽤的情况：</p><ol><li>采⽤ Redis 集群，避免单机出现问题整个缓存服务都没办法使⽤。</li><li>限流，避免同时处理⼤量的请求。</li></ol><p>针对热点缓存失效的情况：</p><ol><li>数据有效期策略调整<ul><li>根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</li><li>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</li></ul></li><li>缓存永不失效。</li></ol><p><strong>总结：</strong>缓存雪崩就是<strong>瞬间过期数据量太大，导致对数据库服务器造成压力。</strong>如能够有效避免过期时间集中，可以有效解决雪崩现象的出现<br>（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p><h2 id="14-3-缓存击穿"><a href="#14-3-缓存击穿" class="headerlink" title="14.3 缓存击穿"></a>14.3 缓存击穿</h2><p><strong>问题：</strong></p><ol><li>Redis中<strong>某个key</strong>过期，该key访问量巨大</li><li>多个数据请求从服务器直接压到Redis后，均未命中</li><li>Redis在短时间内发起了大量对数据库中<strong>同一数据的访问</strong></li></ol><p><strong>解决方案：</strong></p><ol><li>预先设定<br>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长<br>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</li><li>现场调整<br>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li><li>后台刷新数据<br>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li><li>二级缓存<br>设置不同的失效时间，保障不会被同时淘汰就行</li><li>加锁<br>分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</li></ol><p><strong>总结</strong>：缓存击穿就是<strong>单个高热数据过期的瞬间，数据访问量较大</strong>，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度<br>较高，配合雪崩处理策略即可。</p><h2 id="14-4-缓存穿透"><a href="#14-4-缓存穿透" class="headerlink" title="14.4 缓存穿透"></a>14.4 缓存穿透</h2><p><strong>问题：</strong></p><ul><li>获取的数据在Redis和数据库中都不存在，数据库查询未得到对应数据</li><li>Redis获取到null数据未进行持久化，直接返回</li><li>下次此类数据到达重复上述过程</li><li>出现黑客攻击服务</li></ul><p><strong>解决方案：</strong></p><ol><li>缓存null【无效key】<br>对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</li><li>白名单策略</li></ol><ul><li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放<br>行，加载异常数据时直接拦截（效率偏低）</li><li> <strong>使用布隆过滤器</strong>（有关布隆过滤器的命中问题对当前状况可以忽略）</li></ul><ol start="3"><li>实施监控<br> 实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比</li></ol><ul><li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</li><li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象<br>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li></ul><ol start="4"><li>key加密<br> 问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验<br> 例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</li></ol><p>缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力,根本没有经过缓存这⼀层。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。</p><h2 id="14-5-性能指标监控"><a href="#14-5-性能指标监控" class="headerlink" title="14.5 性能指标监控"></a>14.5 性能指标监控</h2><ul><li> 性能指标：Performance</li><li> 内存指标：Memory</li><li> 基本活动指标：Basic activity</li><li>持久性指标：Persistence</li><li>错误指标：Error</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learn</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
