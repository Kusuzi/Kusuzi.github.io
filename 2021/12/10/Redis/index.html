

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/tree.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#447EA5">
  <meta name="description" content="kusuzi Blog">
  <meta name="author" content="Kusuzi">
  <meta name="keywords" content="">
  <meta name="description" content="本篇文章是根据黑马程序员的视频，学习所做的笔记🦊。 1. Redis的简单介绍概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。 类型：非关系型数据库（Nosql） 特征：  可扩容，可伸缩 大数据量下高性能 灵活的数据模型 高可用  关键词：单线程、高性能、多数据类型、持久化 2. Redis的应用">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2021/12/10/Redis/index.html">
<meta property="og:site_name" content="kusuzi">
<meta property="og:description" content="本篇文章是根据黑马程序员的视频，学习所做的笔记🦊。 1. Redis的简单介绍概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。 类型：非关系型数据库（Nosql） 特征：  可扩容，可伸缩 大数据量下高性能 灵活的数据模型 高可用  关键词：单线程、高性能、多数据类型、持久化 2. Redis的应用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/string_01.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/hash_01.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/list_1.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/set1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sorted_set.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sorted_set2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/jedis_1.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/jedis_02.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/jedis_03.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/jedis_04.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/permenent.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/rdb_1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/rdb_2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/rdb_3.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/rdb_4.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/aof_1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/aof-process.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/aof-rewrite.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/aof_2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/tx_1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/del_1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/%E4%B8%BB%E4%BB%8E_01.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/%E9%9B%86%E7%BE%A4.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/主从流程_01.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/stage_01.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/stage_02.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/stage_23.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sential_config.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sential_stage01.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sential_stage02.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sential_stage03.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/stage032.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/cluster.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/slot_cal.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/slot.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/cluster_com.png">
<meta property="article:published_time" content="2021-12-10T09:00:18.000Z">
<meta property="article:modified_time" content="2021-12-25T02:08:11.535Z">
<meta property="article:author" content="Kusuzi">
<meta property="article:tag" content="learn">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/string_01.png">
  
  <title>Redis - kusuzi</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Kusuzi</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/page.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Redis">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-10 17:00" pubdate>
        2021年12月10日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      18k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      55 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis</h1>
            
            <div class="markdown-body">
              <p> 本篇文章是根据<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CJ411m7Gc">黑马程序员</a>的视频，学习所做的笔记🦊。</p>
<h1 id="1-Redis的简单介绍"><a href="#1-Redis的简单介绍" class="headerlink" title="1. Redis的简单介绍"></a>1. Redis的简单介绍</h1><p><strong>概念：</strong>Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的<em>高性能键值对（key-value）数据库。</em></p>
<p><strong>类型</strong>：非关系型数据库（Nosql）</p>
<p><strong>特征：</strong></p>
<ul>
<li>可扩容，可伸缩</li>
<li>大数据量下高性能</li>
<li>灵活的数据模型</li>
<li>高可用</li>
</ul>
<p><strong>关键词：</strong>单线程、高性能、多数据类型、持久化</p>
<h1 id="2-Redis的应用"><a href="#2-Redis的应用" class="headerlink" title="2. Redis的应用"></a>2. Redis的应用</h1><ul>
<li>为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等</li>
<li>任务队列，如秒杀、抢购、购票排队等</li>
<li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设<br>备信号等 </li>
<li>时效性信息控制，如验证码控制、投票控制等</li>
<li>分布式数据共享，如分布式集群架构中的 session 分离</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
<h1 id="3-Redis的五大数据类型"><a href="#3-Redis的五大数据类型" class="headerlink" title="3. Redis的五大数据类型"></a>3. Redis的五大数据类型</h1><p>​        <strong>redis                             java</strong></p>
<ul>
<li><p>String                          String</p>
</li>
<li><p>hash                          HashMap</p>
</li>
<li><p>list                             LinkedList</p>
</li>
<li><p>set                              HashSet</p>
</li>
<li><p>sortedset(zset)          TreeSet</p>
<p>数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串</p>
</li>
</ul>
<h1 id="4-Redis对不同数据类型的常见命令"><a href="#4-Redis对不同数据类型的常见命令" class="headerlink" title="4. Redis对不同数据类型的常见命令"></a>4. Redis对不同数据类型的常见命令</h1><h2 id="4-1-String"><a href="#4-1-String" class="headerlink" title="4.1 String"></a>4.1 String</h2><ul>
<li> 存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li>
<li> 存储数据的格式：一个存储空间保存一个数据</li>
<li>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</li>
</ul>
<ol>
<li><strong>基本命令：</strong></li>
</ol>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">set <span class="hljs-built_in">key</span> value                                         [添加/修改单条数据]<br><span class="hljs-built_in">get</span> <span class="hljs-built_in">key</span>                                               [获取单条数据]<br><span class="hljs-built_in">del</span> <span class="hljs-built_in">key</span>                                               [删除数据]<br>setex <span class="hljs-built_in">key</span>  <span class="hljs-built_in">second</span> value                               [设置<span class="hljs-built_in">key</span>的生命周期]<br>incr <span class="hljs-built_in">key</span>                                              [为某一个<span class="hljs-built_in">key</span>做自增操作，++<span class="hljs-built_in">key</span>]<br>decr <span class="hljs-built_in">key</span> <br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>其他命令:</strong></li>
</ol>
<blockquote>
<p><strong>mset</strong> key1 value1 key2 value2 … 【添加/修改多条数据】</p>
<p><strong>mget</strong> key1 key2 …                                【获取多条数据】</p>
<p><strong>strlen</strong> key                                    【获取数据字符个数（字符串长度）】</p>
<p><strong>append</strong> key value       [ 追加信息到原始信息后部（如果原始信息存在就追加，否则新建）]</p>
</blockquote>
<p>set 和 mset之间的选择问题：如果查询数据量较多时，可以选择mset来节约服务器与redis之间的往返时间</p>
<blockquote>
<p><strong>incrby</strong>  key   increment                         【为某一个key加上increment，但只能是整数】</p>
<p><strong>incrbyfloat</strong> key increment                  【为某一个key加上increment，可以是小数】</p>
<p><strong>decrby</strong> key increment</p>
</blockquote>
<p>string 作为数值操作:</p>
<ul>
<li><p>string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算。</p>
</li>
<li><p>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发<br>带来的数据影响。</p>
</li>
<li><p>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。<br>9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</p>
<p>string 类型数据操作的注意事项</p>
<blockquote>
<p> <strong>数据操作不成功的反馈与数据正常操作之间的差异</strong></p>
<p>① 表示运行结果是否成功</p>
<p>(integer) 0 → false 失败<br> (integer) 1 → true  成功<br>② 表示运行结果值<br> (integer) 3 → 3 3个<br>(integer) 1 → 1 1个<br> <strong>数据未获取到</strong><br>（nil）等同于null<br><strong>数据最大存储量</strong><br>512MB<br> <strong>数值计算最大范围（java中的long的最大值）</strong><br>9223372036854775807</p>
</blockquote>
</li>
</ul>
<p><strong>业务场景</strong>：主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量</p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/string_01.png" srcset="/img/loading.gif" lazyload alt="string_01"></p>
<h2 id="4-2-hash"><a href="#4-2-hash" class="headerlink" title="4.2 hash"></a>4.2 hash</h2><ul>
<li>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</li>
<li>需要的存储结构：一个存储空间保存多个键值对数据</li>
<li>hash类型：底层使用哈希表结构实现数据存储</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/hash_01.png" srcset="/img/loading.gif" lazyload alt="hash_01"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">hset key field value         [添加/修改数据]<br>hget key field               [获取数据]<br>hgetall key                  <br>hdel key field1 [field2]     [删除数据]      <br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>其他命令</strong> </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">hmset key field1 value1 field2 value2 … <br>hmget key field1 field2 … <br>hlen key                    [获取哈希表中field字段的数量]<br>hexists key field           [获取哈希表中是否存在指定的字段]<br>    <br>hkeys key                   [ 获取哈希表中所有的字段名或字段值]<br>hvals key<br>hincrby key field increment [设置指定字段的数值数据增加指定范围的值]<br>hincrbyfloat key field increment<br></code></pre></td></tr></table></figure>

<p>hash 类型数据操作的注意事项 </p>
<ul>
<li><p>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，<br>对应的值为（nil）</p>
</li>
<li><p>hash 类型数据操作的注意事项</p>
</li>
<li><p>每个 hash 可以存储 2 32 - 1 个键值对</p>
</li>
<li><p>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存<br>储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用</p>
</li>
<li><p>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问<br>瓶颈</p>
</li>
</ul>
<p>对比：string存储对象（json）<strong>VS</strong> hash存储对象</p>
<p>String的好处：将对象的内容组装为一个整体，更倾向于<em>读取</em> </p>
<p>hash的好处：将对象的内容分成不同的field，更倾向于<em>更新</em></p>
<h2 id="4-3-list"><a href="#4-3-list" class="headerlink" title="4.3 list"></a>4.3 list</h2><ul>
<li> 数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</li>
<li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</li>
<li>list类型：保存多个数据，底层使用<strong>双向链表</strong>存储结构实现</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/list_1.jpg" srcset="/img/loading.gif" lazyload alt="list_1"></p>
<ol>
<li><p><strong>基本命令</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">lpush key value1 [value2] ……        【 添加/修改数据】<br>rpush key value1 [value2] ……<br>  <br>lrange key start stop                【获取数据】<br>lindex key index<br>llen key <br>    <br>lpop key                            【获取并移除数据】<br>rpop key<br></code></pre></td></tr></table></figure></li>
<li><p><strong>其他命令</strong></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">blpop key1 [key2] <span class="hljs-keyword">timeout</span>           [ 规定时间内获取并移除数据]<br>brpop key1 [key2] <span class="hljs-keyword">timeout</span><br>brpoplpush source destination <span class="hljs-keyword">timeout</span><br><br>lrem key <span class="hljs-built_in">count</span> value                [移除指定数据,<span class="hljs-built_in">count</span>表示为：移掉多少个]<br></code></pre></td></tr></table></figure>

<p>相当于阻塞，如果list中没有数据则阻塞，在规定的时间内有数据就输出并移除</p>
</li>
<li><p><strong>注意事项</strong></p>
<ul>
<li>list中保存的数据都是string类型的，数据总容量是有限的，最多2 32 - 1 个元素 (4294967295)。</li>
<li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作</li>
<li>获取全部数据操作结束索引设置为-1</li>
<li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</li>
</ul>
</li>
<li><p><strong>业务场景</strong></p>
<ul>
<li>twitter、新浪微博、腾讯微博中个人用户的<strong>关注列表</strong>需要按照用户的关注顺序进行展示，粉丝列表需要将最<br>近关注的粉丝列在前面</li>
<li>新闻、资讯类网站如何将最新的新闻或资讯按照发生的<strong>时间顺序展示？</strong></li>
</ul>
</li>
</ol>
<h2 id="4-4-set"><a href="#4-4-set" class="headerlink" title="4.4 set"></a>4.4 set</h2><ul>
<li><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率</p>
</li>
<li><p>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</p>
</li>
<li><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的</p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/set1.png" srcset="/img/loading.gif" lazyload alt="set1"></p>
</li>
</ul>
<ol>
<li>基本命令</li>
</ol>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sadd</span> key member<span class="hljs-number">1</span><span class="hljs-meta"> [member2]        [添加数据]</span><br><span class="hljs-attribute">smembers</span> key                     <span class="hljs-meta"> [获取全部数据]</span><br><span class="hljs-attribute">srem</span> key member<span class="hljs-number">1</span><span class="hljs-meta"> [member2]        [删除数据]</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>其他命令</strong></li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">scard key                         <span class="hljs-selector-attr">[获取集合数据总量]</span><br>sismember key member              <span class="hljs-selector-attr">[判断集合中是否包含指定数据]</span><br>srandmember key <span class="hljs-selector-attr">[count]</span>           <span class="hljs-selector-attr">[随机获取集合中指定数量的数据]</span><br>spop key <span class="hljs-selector-attr">[count]</span>                  <span class="hljs-selector-attr">[随机获取集合中的某个数据并将该数据移出集合]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sinter</span> key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]               [求两个集合的交、并、差集]</span><br><span class="hljs-attribute">sunion</span> key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]</span><br><span class="hljs-attribute">sdiff</span> key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]</span><br><br><span class="hljs-attribute">sinterstore</span> destination key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]  [求两个集合的交、并、差集并存储到指定集合中]</span><br><span class="hljs-attribute">sunionstore</span> destination key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]</span><br><span class="hljs-attribute">sdiffstore</span> destination key<span class="hljs-number">1</span><span class="hljs-meta"> [key2]</span><br><br><span class="hljs-attribute">smove</span> source destination member     <span class="hljs-meta"> [将指定数据从原始集合中移动到目标集合中]</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>注意事项</strong></li>
</ol>
<ul>
<li> set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份</li>
<li> set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间【set中的value类似于hash中的field】</li>
</ul>
<ol start="4">
<li><strong>业务场景</strong></li>
</ol>
<ul>
<li>redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，<br>大V推荐等</li>
<li>新浪微博为了增加用户热度，提高用户留存性，需要微博用户在关注更多的人，以此获得更多的信息或热门<br>话题，如何提高用户关注他人的总量？</li>
<li>共同好友、共同关注等</li>
<li>redis 应用于同类型数据的快速去重</li>
<li>设置白名单或者黑名单</li>
</ul>
<h2 id="4-5-sorteds-set"><a href="#4-5-sorteds-set" class="headerlink" title="4.5 sorteds_set"></a>4.5 sorteds_set</h2><ul>
<li><p>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p>
</li>
<li><p>需要的存储结构：新的存储模型，可以保存可排序的数据</p>
</li>
<li><p>sorted_set类型：在set的存储结构基础上添加<strong>可排序字段</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sorted_set.png" srcset="/img/loading.gif" lazyload alt="sorted_set"></p>
</li>
</ul>
<ol>
<li><p><strong>基本命令</strong></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">zadd</span> <span class="hljs-selector-tag">key</span> <span class="hljs-selector-tag">score1</span> <span class="hljs-selector-tag">member1</span> <span class="hljs-selector-attr">[score2 member2]</span>           <span class="hljs-selector-attr">[添加数据]</span>  <br><br><span class="hljs-selector-tag">zrange</span> <span class="hljs-selector-tag">key</span> <span class="hljs-selector-tag">start</span> <span class="hljs-selector-tag">stop</span> <span class="hljs-selector-attr">[WITHSCORES]</span>                 <span class="hljs-selector-attr">[获取全部数据]</span>(升序)<br><span class="hljs-selector-tag">zrevrange</span> <span class="hljs-selector-tag">key</span> <span class="hljs-selector-tag">start</span> <span class="hljs-selector-tag">stop</span> <span class="hljs-selector-attr">[WITHSCORES]</span>               (降序)<br><br><span class="hljs-selector-tag">zrem</span> <span class="hljs-selector-tag">key</span> <span class="hljs-selector-tag">member</span> <span class="hljs-selector-attr">[member ...]</span>                       <span class="hljs-selector-attr">[删除数据]</span><br></code></pre></td></tr></table></figure></li>
<li><p><strong>其他命令</strong></p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xquery">zrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> min</span><span class="hljs-built_in"> max</span> [WITHSCORES] [LIMIT]         [按条件获取数据]<br>zrevrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> max</span><span class="hljs-built_in"> min</span> [WITHSCORES]<br><br>zremrangebyrank<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> stop                         [条件删除数据]<br>zremrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> min</span><span class="hljs-built_in"> max</span><br><br></code></pre></td></tr></table></figure>

<ul>
<li> min与max用于限定搜索查询的条件</li>
<li> start与stop用于限定查询范围，作用于索引，表示开始和结束索引</li>
<li>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zcard <span class="hljs-built_in">key</span>                                              [获取集合数据总量]           <br>zcount <span class="hljs-built_in">key</span> <span class="hljs-built_in">min</span> <span class="hljs-built_in">max</span>                                     [集合交、并操作]<br><br>zrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>                                      [获取数据对应的索引（排名）]<br>zrevrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span><br>   <br>zscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>                                      score值获取与修改<br>zincrby <span class="hljs-built_in">key</span> increment <span class="hljs-built_in">member</span><br></code></pre></td></tr></table></figure></li>
<li><p><strong>注意事项</strong></p>
<ul>
<li> score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li>
<li>score保存的数据也可以是一个<strong>双精度的double值</strong>，基于双精度浮点数的特征，可能会丢失精度，使用时<br>候要慎重</li>
<li>sorted_set 底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反<br>复覆盖，保留最后一次修改的结果</li>
</ul>
</li>
<li><p><strong>业务场景</strong></p>
<ul>
<li>票选广东十大杰出青年，各类综艺选秀海选投票</li>
<li>各类资源网站TOP10（电影，歌曲，文档，电商，游戏等）</li>
<li>聊天室活跃度统计</li>
<li>游戏好友亲密度</li>
<li>redis 应用于即时任务/消息队列执行管理(对于高优先级的任务要保障对其优先处理)</li>
</ul>
</li>
</ol>
<h2 id="4-6-数据类型实践案例"><a href="#4-6-数据类型实践案例" class="headerlink" title="4.6 数据类型实践案例"></a>4.6 数据类型实践案例</h2><p>业务场景：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sorted_set2.png" srcset="/img/loading.gif" lazyload alt="sorted_set2"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CJ411m7Gc?p=32">代码实现</a></p>
<h1 id="5-Redis-通用指令"><a href="#5-Redis-通用指令" class="headerlink" title="5. Redis 通用指令"></a>5. Redis 通用指令</h1><h2 id="5-1-key-通用指令"><a href="#5-1-key-通用指令" class="headerlink" title="5.1 key 通用指令"></a>5.1 key 通用指令</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs maxima">keys *       [查看所有的<span class="hljs-built_in">key</span>]<br><span class="hljs-built_in">del</span> <span class="hljs-built_in">key</span>      [删除指定的<span class="hljs-built_in">key</span>]<br>exists <span class="hljs-built_in">key</span>   [获取<span class="hljs-built_in">key</span>是否存在]<br>type <span class="hljs-built_in">key</span>     [获取<span class="hljs-built_in">key</span>的类型]<br>expire <span class="hljs-built_in">key</span> seconds [设置指定<span class="hljs-built_in">key</span>的有效期]<br>ttl <span class="hljs-built_in">key</span>       [获取指定<span class="hljs-built_in">key</span>的有效时间]<br>pttl <span class="hljs-built_in">key</span><br><span class="hljs-built_in">rename</span> <span class="hljs-built_in">key</span> newkey   [为<span class="hljs-built_in">key</span>改名]<br>renamenx <span class="hljs-built_in">key</span> newkey<br></code></pre></td></tr></table></figure>

<h2 id="5-2-数据库通用指令"><a href="#5-2-数据库通用指令" class="headerlink" title="5.2 数据库通用指令"></a>5.2 数据库通用指令</h2><ul>
<li><p>redis为每个服务提供有16个数据库，编号从0到15</p>
</li>
<li><p>每个数据库之间的数据相互独立</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">select</span> <span class="hljs-meta">index</span>   [切换数据库]<br><span class="hljs-keyword">quit</span><br><span class="hljs-keyword"></span>move <span class="hljs-meta">key</span> db    [数据移动]<br>dbsize         [数据清除]<br>flushdb<br>flushall<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6. Jedis"></a>6. Jedis</h1><h2 id="6-1-准备工作"><a href="#6-1-准备工作" class="headerlink" title="6.1 准备工作"></a>6.1 准备工作</h2><ul>
<li><p>导入jedis坐标</p>
<blockquote>
<dependency>
<groupId>redis.clients</groupId>
<artifactId>jedis</artifactId>
<version>2.9.0</version>
</dependency></blockquote>
</li>
<li><p>连接jedis</p>
<blockquote>
<p>Jedis jedis = new Jedis(“localhost”, 6379);</p>
</blockquote>
</li>
<li><p>操作jedis</p>
</li>
<li><p>关闭jedis连接</p>
<blockquote>
<p>jedis.close();</p>
</blockquote>
</li>
</ul>
<h2 id="6-2-案例"><a href="#6-2-案例" class="headerlink" title="6.2 案例"></a>6.2 案例</h2><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/jedis_1.jpg" srcset="/img/loading.gif" lazyload alt="jedis_1"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CJ411m7Gc?p=44">代码演示</a></p>
<p>主程序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/jedis_02.jpg" srcset="/img/loading.gif" lazyload alt="jedis_02"></p>
<img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/jedis_03.jpg" srcset="/img/loading.gif" lazyload alt="jedis_03"  />

<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/jedis_04.jpg" srcset="/img/loading.gif" lazyload alt="jedis_04"></p>
<h2 id="6-3-jedis简易工具类开发"><a href="#6-3-jedis简易工具类开发" class="headerlink" title="6.3 jedis简易工具类开发"></a>6.3 jedis简易工具类开发</h2><p> JedisPool：Jedis提供的连接池技术</p>
<p>需要的三个内容：</p>
<p>poolConfig:连接池配置对象<br>host:redis服务地址<br>port:redis服务端口号</p>
<blockquote>
<p>//设置poolConfig</p>
<p>poolConfig = new JedisPoolConfig();<br>poolConfig.setMaxTotal(maxTotal);<br>poolConfig.setMaxIdle(maxIdle);</p>
<p>// 设置JedisPool</p>
<p>jedisPool = new JedisPool(poolConfig,host,port);</p>
</blockquote>
<h1 id="7-Redis的linux环境安装"><a href="#7-Redis的linux环境安装" class="headerlink" title="7. Redis的linux环境安装"></a>7. Redis的linux环境安装</h1><h2 id="7-1-基于Center-OS7安装Redis"><a href="#7-1-基于Center-OS7安装Redis" class="headerlink" title="7.1 基于Center OS7安装Redis"></a>7.1 基于Center OS7安装Redis</h2><ul>
<li>下载安装包<br>wget <a target="_blank" rel="noopener" href="http://download.redis.io/releases/redis-?.?.?.tar.gz">http://download.redis.io/releases/redis-?.?.?.tar.gz</a></li>
<li>解压<br>tar –xvf 文件名.tar.gz</li>
<li>编译<br>make</li>
<li>安装<br>make install [destdir=/目录]</li>
</ul>
<h2 id="7-2-Redis服务器端启动"><a href="#7-2-Redis服务器端启动" class="headerlink" title="7.2 Redis服务器端启动"></a>7.2 Redis服务器端启动</h2><ol>
<li><p>默认：redis-server</p>
<p>如果想启动多个redis服务器，则需要换端口，那么对应的客户端也需要指定这个端口号</p>
</li>
<li><p>redis-server –port xxx(端口号)</p>
<p>redis-cli –port xxx</p>
</li>
<li><p>通过配置文件启动</p>
<ul>
<li><p>cp redis-6379.conf redis-6380.conf  [复制配置文件]</p>
</li>
<li><p>修改新的配置文件的端口号和日志名</p>
</li>
<li><p>启动对应端口的配置文件</p>
<p>redis-server redis-6380.conf</p>
</li>
</ul>
</li>
</ol>
<h1 id="8-Redis持久化"><a href="#8-Redis持久化" class="headerlink" title="8. Redis持久化"></a>8. Redis持久化</h1><h2 id="8-1持久化简介"><a href="#8-1持久化简介" class="headerlink" title="8.1持久化简介"></a>8.1持久化简介</h2><p><strong>什么是持久化：</strong></p>
<p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p>
<p><strong>为什么要进行持久化：</strong></p>
<p>防止数据的意外丢失，确保数据安全性</p>
<p><strong>持久化过程保存什么：</strong></p>
<ul>
<li><p> 将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据</p>
</li>
<li><p>将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程</p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/permenent.png" srcset="/img/loading.gif" lazyload alt="permenent"></p>
</li>
</ul>
<h2 id="8-2-RDB"><a href="#8-2-RDB" class="headerlink" title="8.2 RDB"></a>8.2 RDB</h2><h3 id="8-2-1RDB启动方式-——-save指令"><a href="#8-2-1RDB启动方式-——-save指令" class="headerlink" title="8.2.1RDB启动方式 —— save指令"></a>8.2.1<strong>RDB启动方式 —— save指令</strong></h3><blockquote>
<p>save</p>
<p>作用：手动执行一次保存操作</p>
</blockquote>
<p>相关配置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/rdb_1.png" srcset="/img/loading.gif" lazyload alt="rdb_1"></p>
<p>save工作原理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/rdb_2.png" srcset="/img/loading.gif" lazyload alt="rdb_2"></p>
<p><strong>注意：save指令的执行会<u>阻塞当前Redis服务器，</u>直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用。</strong></p>
<h3 id="8-2-2-RDB启动方式-——-bgsave指令"><a href="#8-2-2-RDB启动方式-——-bgsave指令" class="headerlink" title="8.2.2 RDB启动方式 —— bgsave指令"></a>8.2.2 RDB启动方式 —— bgsave指令</h3><blockquote>
<p>bgsave</p>
<p>作用：手动启动后台保存操作，但不是立即执行</p>
</blockquote>
<p>bgsave工作原理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/rdb_3.png" srcset="/img/loading.gif" lazyload alt="rdb_3"></p>
<p>注意： bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用</p>
<p>以上两种方式均为手动保存，通过配置文件的方式是自动保存</p>
<h3 id="8-2-3-RDB启动方式-——save配置"><a href="#8-2-3-RDB启动方式-——save配置" class="headerlink" title="8.2.3 RDB启动方式 ——save配置"></a>8.2.3 RDB启动方式 ——save配置</h3><ul>
<li><p>配置</p>
<blockquote>
<p>save second changes</p>
</blockquote>
</li>
<li><p>作用<br>满足限定时间范围内key的变化数量达到指定数量即进行持久化</p>
</li>
<li><p>参数<br>second：监控时间范围<br>changes：监控key的变化量</p>
</li>
<li><p>位置<br>在conf文件中进行配置</p>
</li>
<li><p>范例</p>
<blockquote>
<p>save 900 1<br>save 300 10<br>save 60 10000</p>
</blockquote>
<p>注意：save配置启动后执行的是bgsave操作</p>
<p>RDB三种启动方式对比</p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/rdb_4.png" srcset="/img/loading.gif" lazyload alt="rdb_4"></p>
</li>
</ul>
<h3 id="8-2-4-总结"><a href="#8-2-4-总结" class="headerlink" title="8.2.4 总结"></a>8.2.4 总结</h3><p><strong>优点：</strong></p>
<ul>
<li> RDB是一个紧凑压缩的二进制文件，存储效率较高</li>
<li>RDB内部存储的是redis在某个时间点的<strong>数据快照</strong>，非常适合用于数据备份，全量复制等场景</li>
<li>RDB<strong>恢复数据</strong>的速度要比AOF<strong>快</strong>很多</li>
<li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li>
<li> bgsave指令每次运行要执行<strong>fork操作创建子进程</strong>，要牺牲掉一些性能</li>
<li> Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现<strong>各版本</strong>服务之间数据格式<strong>无法兼容现象</strong></li>
</ul>
<h2 id="8-3-AOF"><a href="#8-3-AOF" class="headerlink" title="8.3 AOF"></a>8.3 AOF</h2><h3 id="8-3-1-AOF概念"><a href="#8-3-1-AOF概念" class="headerlink" title="8.3.1 AOF概念"></a>8.3.1 AOF概念</h3><ul>
<li>AOF(append only file)持久化：以<strong>独立日志</strong>的方式记录每次写<strong>命令</strong>，重启时再重新执行AOF文件中命令<br>达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</li>
<li>AOF的主要作用是解决了<strong>数据持久化的实时性</strong>，目前已经是Redis持久化的主流方式</li>
</ul>
<h3 id="8-3-2-AOF写数据三种策略-appendfsync"><a href="#8-3-2-AOF写数据三种策略-appendfsync" class="headerlink" title="8.3.2 AOF写数据三种策略(appendfsync)"></a>8.3.2 AOF写数据三种策略(appendfsync)</h3><ul>
<li>always(每次）<br>每次写入操作均同步到AOF文件中，数据零误差，性能较低</li>
<li>everysec（每秒）<br>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高<br>在系统突然宕机的情况下丢失1秒内的数据</li>
<li>no（系统控制）<br>由操作系统控制每次同步到AOF文件的周期，整体过程不可控</li>
</ul>
<h3 id="8-3-3-AOF功能开启"><a href="#8-3-3-AOF功能开启" class="headerlink" title="8.3.3 AOF功能开启"></a>8.3.3 AOF功能开启</h3><ul>
<li><p>配置</p>
<blockquote>
<p>appendonly yes|no</p>
</blockquote>
</li>
<li><p>作用<br>是否开启AOF持久化功能，默认为不开启状态</p>
</li>
<li><p>配置</p>
<blockquote>
<p>appendfsync always|everysec|no</p>
</blockquote>
</li>
<li><p>作用<br>AOF写数据策略</p>
</li>
</ul>
<h3 id="8-3-4-AOF重写"><a href="#8-3-4-AOF重写" class="headerlink" title="8.3.4 AOF重写"></a>8.3.4 AOF重写</h3><p><strong>作用：</strong></p>
<ul>
<li>降低磁盘占用量，提高磁盘利用率</li>
<li>提高持久化效率，降低持久化写时间，提高IO性能</li>
<li>降低数据恢复用时，提高数据恢复效率</li>
</ul>
<p><strong>重写规则：</strong></p>
<ul>
<li>进程内已超时的数据不再写入文件</li>
<li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<pre><code>  如del key1、 hdel key2、srem key3、set key4 111、set key4 222等
</code></pre>
</li>
<li>对同一数据的多条写命令合并为一条命令<pre><code> 如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c。
为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素
</code></pre>
</li>
</ul>
<p><strong>重写方式：</strong></p>
<ul>
<li><p>手动重写</p>
<blockquote>
<p>bgrewriteaof</p>
</blockquote>
</li>
<li><p> 自动重写</p>
</li>
</ul>
<blockquote>
<p>auto-aof-rewrite-min-size size<br>auto-aof-rewrite-percentage percentage</p>
</blockquote>
<p><strong>工作原理：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/aof_1.png" srcset="/img/loading.gif" lazyload alt="aof_1"></p>
<p><strong>工作流程：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/aof-process.png" srcset="/img/loading.gif" lazyload alt="aof-process"></p>
<p>AOF重写流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/aof-rewrite.png" srcset="/img/loading.gif" lazyload alt="aof-rewrite"></p>
<h3 id="8-4-RDB-VS-AOF"><a href="#8-4-RDB-VS-AOF" class="headerlink" title="8.4 RDB VS AOF"></a>8.4 RDB VS AOF</h3><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/aof_2.png" srcset="/img/loading.gif" lazyload alt="aof_2"></p>
<ul>
<li><p>对数据非常敏感，建议使用默认的AOF持久化方案</p>
<ul>
<li><p>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出<br>现问题时，最多丢失0-1秒内的数据。</p>
</li>
<li><p>注意：由于AOF文件存储体积较大，且恢复速度较慢</p>
</li>
</ul>
</li>
<li><p>数据呈现阶段有效性，建议使用RDB持久化方案</p>
<ul>
<li><p>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段<br>点数据恢复通常采用RDB方案</p>
</li>
<li><p>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：</p>
</li>
</ul>
</li>
<li><p>综合比对</p>
<ul>
<li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li>
<li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF</li>
<li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li>
<li>灾难恢复选用RDB</li>
<li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量</li>
</ul>
</li>
</ul>
<h1 id="9-Redis事务"><a href="#9-Redis事务" class="headerlink" title="9. Redis事务"></a>9. Redis事务</h1><h2 id="9-1-事务简介"><a href="#9-1-事务简介" class="headerlink" title="9.1 事务简介"></a>9.1 事务简介</h2><p>redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性<br>按照添加顺序依次执行，中间不会被打断或者干扰。一个队列中，一次性、顺序性、排他性的执行一系列命令。</p>
<h2 id="9-2-事务基本操作"><a href="#9-2-事务基本操作" class="headerlink" title="9.2 事务基本操作"></a>9.2 事务基本操作</h2><h3 id="9-2-1-基本命令"><a href="#9-2-1-基本命令" class="headerlink" title="9.2.1 基本命令"></a>9.2.1 基本命令</h3><ul>
<li> 开启事务</li>
</ul>
<blockquote>
<p>multi</p>
</blockquote>
<ul>
<li><p>作用</p>
<p>设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</p>
</li>
<li><p>执行事务</p>
<blockquote>
<p>exec</p>
</blockquote>
</li>
<li><p>作用</p>
<p>设定事务的结束位置，同时执行事务。与multi成对出现，成对使用</p>
<p><strong><font color='red'>注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</font></strong></p>
</li>
<li><p> 取消事务</p>
</li>
</ul>
<blockquote>
<p>discard</p>
</blockquote>
<ul>
<li><p>作用</p>
<p>终止当前事务的定义，发生在multi之后，exec之前</p>
<h3 id="9-2-2-事务的工作流程"><a href="#9-2-2-事务的工作流程" class="headerlink" title="9.2.2 事务的工作流程"></a>9.2.2 事务的工作流程</h3><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/tx_1.png" srcset="/img/loading.gif" lazyload alt="tx_1"></p>
</li>
</ul>
<h3 id="9-2-3-事务的注意事项"><a href="#9-2-3-事务的注意事项" class="headerlink" title="9.2.3 事务的注意事项"></a>9.2.3 事务的注意事项</h3><ul>
<li>定义事务的过程中，<strong>命令格式****输入</strong>错误怎么办？<ul>
<li>语法错误<pre><code>指命令书写格式有误
</code></pre>
</li>
<li>处理结果<pre><code> 如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。
</code></pre>
</li>
</ul>
</li>
<li>定义事务的过程中，<strong>命令执行</strong>出现错误怎么办？<ul>
<li>运行错误<pre><code>指命令格式正确，但是无法正确的执行。例如对list进行incr操作
</code></pre>
</li>
<li>处理结果<br>  能够正确运行的命令会执行，运行错误的命令不会被执行[错的和正确地各执行各的]</li>
</ul>
</li>
</ul>
<p><font color='red'>注意：已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</font></p>
<h3 id="9-2-4-手动进行事务回滚"><a href="#9-2-4-手动进行事务回滚" class="headerlink" title="9.2.4 手动进行事务回滚"></a>9.2.4 手动进行事务回滚</h3><ul>
<li>记录操作过程中被影响的数据之前的状态<pre><code>    单数据：string
      多数据：hash、list、set、zset
</code></pre>
</li>
<li>设置指令恢复所有的被修改的项<pre><code>  单数据：直接set（注意周边属性，例如时效）
  多数据：修改对应值或整体克隆复制
</code></pre>
</li>
</ul>
<h2 id="9-3-锁"><a href="#9-3-锁" class="headerlink" title="9.3 锁"></a>9.3 锁</h2><p><strong>业务分析1:</strong></p>
<p> 多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作<br> 在操作之前锁定要操作的数据，一旦发生变化，终止当前操作</p>
<p><strong>解决方案1：</strong></p>
<ul>
<li> 对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</li>
</ul>
<blockquote>
<p>watch key1 [key2……]     [只要被监控的发生了变化，则后续的事务都不会被执行，哪怕是没有被监控的对象]</p>
</blockquote>
<ul>
<li><p>取消对所有 key 的监视</p>
<blockquote>
<p>unwatch</p>
</blockquote>
</li>
</ul>
<p><strong>业务分析2:【超卖问题】</strong></p>
<p> 使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据<br> 虽然redis是单线程的，但是多个客户端对同一数据同时进行操作时，如何避免不被同时修改？</p>
<p><strong>解决方案2：</strong></p>
<ul>
<li> 使用 setnx 设置一个公共锁</li>
</ul>
<blockquote>
<p>setnx lock-key value</p>
</blockquote>
<p>  利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功<br>           对于返回设置成功的，拥有控制权，进行下一步的具体业务操作<br>          对于返回设置失败的，不具有控制权，排队或等待<br>  操作完毕通过del操作释放锁</p>
<p>  注意：上述解决方案是一种设计概念，依赖规范保障，具有风险性</p>
<p><strong>业务分析3:</strong></p>
<p> 由于锁操作由用户控制加锁解锁，必定会存在<font color='cornflowerblue'>加锁后未解锁</font>的风险<br> 需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案</p>
<p><strong>解决方案3：</strong></p>
<ul>
<li> 使用 expire 为锁key添加时间限定，到时不释放，放弃锁</li>
</ul>
<blockquote>
<p>expire lock-key second<br>pexpire lock-key milliseconds</p>
</blockquote>
<p>  由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。<br>        例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。<br>        测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时<br>        锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%<br>        如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</p>
<h1 id="10-Redis删除策略"><a href="#10-Redis删除策略" class="headerlink" title="10. Redis删除策略"></a>10. Redis删除策略</h1><h2 id="10-1-过期数据"><a href="#10-1-过期数据" class="headerlink" title="10.1 过期数据"></a>10.1 过期数据</h2><p>Redis中的数据特征</p>
<ul>
<li>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态<ul>
<li>XX ：具有时效性的数据</li>
<li> -1 ：永久有效的数据</li>
<li> -2 ：已经过期的数据 或 被删除的数据 或 未定义的数据</li>
</ul>
</li>
</ul>
<h2 id="10-2-数据删除策略"><a href="#10-2-数据删除策略" class="headerlink" title="10.2 数据删除策略"></a>10.2 数据删除策略</h2><ol>
<li><p>定时删除</p>
</li>
<li><p>惰性删除</p>
</li>
<li><p>定期删除</p>
<p><strong>时效性数据的存储结构</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/del_1.png" srcset="/img/loading.gif" lazyload alt="del_1"></p>
</li>
</ol>
<h3 id="10-2-1-定时删除"><a href="#10-2-1-定时删除" class="headerlink" title="10.2.1 定时删除"></a>10.2.1 定时删除</h3><ul>
<li> 创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</li>
<li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用</li>
<li>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li>
<li>总结：用处理器性能换取存储空间 （拿时间换空间）</li>
</ul>
<h3 id="10-2-2-惰性删除"><a href="#10-2-2-惰性删除" class="headerlink" title="10.2.2 惰性删除"></a>10.2.2 惰性删除</h3><ul>
<li>数据到达过期时间，不做处理。等下次访问该数据时<ul>
<li>如果未过期，返回数据</li>
<li>发现已过期，删除，返回不存在</li>
</ul>
</li>
<li>优点：节约CPU性能，发现必须删除的时候才删除</li>
<li> 缺点：内存压力很大，出现长期占用内存的数据</li>
<li>总结：用存储空间换取处理器性能（拿空间换时间)<br>会用到expireIfNeeded()函数</li>
</ul>
<h3 id="10-2-3-定期删除"><a href="#10-2-3-定期删除" class="headerlink" title="10.2.3 定期删除"></a>10.2.3 定期删除</h3><p><strong>定时轮询，对每个库进行轮询</strong></p>
<ul>
<li><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p>
</li>
<li><p>每秒钟执行server.hz次<strong>serverCron()</strong>——&gt;<strong>databasesCron()</strong>——–&gt;<strong>activeExpireCycle()</strong></p>
</li>
<li><p> <font color='red'>activeExpireCycle()</font>对每个expires[*]逐一进行检测，每次执行250ms/server.hz</p>
</li>
<li><p>*对某个expires[*]检测时，随机挑选W个key检测</p>
</li>
<li><p>如果key超时，删除key</p>
</li>
<li><p>如果一轮中删除的key的数量&gt;W*25%，循环该过程</p>
</li>
<li><p>如果一轮中删除的key的数量≤W<em>25%，检查下一个expires[</em>]，0-15循环</p>
</li>
<li><p>W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值</p>
</li>
<li><p> 参数current_db用于记录<font color='red'>activeExpireCycle() </font>进入哪个expires[*] 执行</p>
</li>
<li><p>如果<font color='red'>activeExpireCycle()</font>执行时间到期，下次从current_db继续向下执行</p>
</li>
</ul>
<p>总结：</p>
<ol>
<li>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</li>
<li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li>
<li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li>
<li>总结：周期性抽查存储空间（随机抽查，重点抽查）</li>
</ol>
<h3 id="10-2-4-删除策略比对"><a href="#10-2-4-删除策略比对" class="headerlink" title="10.2.4 删除策略比对"></a>10.2.4 删除策略比对</h3><table>
<thead>
<tr>
<th>定期删除</th>
<th>内存定期随机清理</th>
<th>每秒花费固定的CPU资源维护内存</th>
<th>随机抽查，重点抽查</th>
</tr>
</thead>
<tbody><tr>
<td>定时删除</td>
<td>节约内存，无占用</td>
<td>不分时段占用CPU资源，频度高</td>
<td>拿时间换空间</td>
</tr>
<tr>
<td>惰性删除</td>
<td>内存占用严重</td>
<td>延时执行，CPU利用率高</td>
<td>拿空间换时间</td>
</tr>
</tbody></table>
<h2 id="10-3-逐出算法（淘汰算法）"><a href="#10-3-逐出算法（淘汰算法）" class="headerlink" title="10.3 逐出算法（淘汰算法）"></a>10.3 逐出算法（淘汰算法）</h2><p>问题：当新数据进入redis时，如果内存不足怎么办？</p>
<ul>
<li>Redis使用内存存储数据，在执行每一个命令前，会调用<font color='red'>freeMemoryIfNeeded()</font>检测内存是否充足。如<br>果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据<br>的策略称为逐出算法。</li>
<li>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所<br>有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</li>
</ul>
<h3 id="10-3-1-影响数据逐出的相关配置"><a href="#10-3-1-影响数据逐出的相关配置" class="headerlink" title="10.3.1. 影响数据逐出的相关配置"></a>10.3.1. 影响数据逐出的相关配置</h3><ul>
<li><p>最大可使用内存</p>
<blockquote>
<p>maxmemory</p>
</blockquote>
<p>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</p>
</li>
<li><p>每次选取待删除数据的个数</p>
<blockquote>
<p>maxmemory-samples</p>
</blockquote>
<p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p>
</li>
<li><p> 删除策略</p>
</li>
</ul>
<blockquote>
<p>maxmemory-policy</p>
</blockquote>
<p>  达到最大内存后的，对被挑选出来的数据进行删除的策略</p>
<h3 id="10-3-2-逐出算法种类"><a href="#10-3-2-逐出算法种类" class="headerlink" title="10.3.2. 逐出算法种类"></a>10.3.2. 逐出算法种类</h3><ol>
<li>检测易失数据（可能会过期的数据集server.db[i].expires ）<br>① volatile-lru：挑选最近最少使用的数据淘汰<br>② volatile-lfu：挑选最近使用次数最少的数据淘汰<br>③ volatile-ttl：挑选将要过期的数据淘汰<br>④ volatile-random：任意选择数据淘汰</li>
<li>检测全库数据（所有数据集server.db[i].dict ）<br>⑤ allkeys-lru：挑选最近最少使用的数据淘汰<br>⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰<br>⑦ allkeys-random：任意选择数据淘汰</li>
<li>放弃数据驱逐<br>⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</li>
</ol>
<p><strong>数据逐出策略配置依据</strong><br> 使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置</p>
<h1 id="11-主从复制"><a href="#11-主从复制" class="headerlink" title="11. 主从复制"></a>11. 主从复制</h1><h2 id="11-1-主从复制简介"><a href="#11-1-主从复制简介" class="headerlink" title="11.1. 主从复制简介"></a>11.1. 主从复制简介</h2><h3 id="11-1-1-互联网“三高”架构"><a href="#11-1-1-互联网“三高”架构" class="headerlink" title="11.1.1. 互联网“三高”架构"></a>11.1.1. 互联网“三高”架构</h3><ul>
<li> 高并发</li>
<li>高性能</li>
<li> 高可用</li>
</ul>
<p><strong>单机redis的风险与问题</strong></p>
<ul>
<li>问题1.机器故障<pre><code>      现象：硬盘故障、系统崩溃
          本质：数据丢失，很可能对业务造成灾难性打击
           结论：基本上会放弃使用redis.
</code></pre>
</li>
<li>问题2.容量瓶颈<pre><code>    现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存
   本质：穷，硬件条件跟不上
   结论：放弃使用redis
</code></pre>
</li>
<li>结论：<pre><code>   为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服
   务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续
  提供服务，实现Redis的高可用，同时实现数据冗余备份。
</code></pre>
</li>
</ul>
<h4 id="11-1-2-多台服务器连接方案"><a href="#11-1-2-多台服务器连接方案" class="headerlink" title="11.1.2. 多台服务器连接方案"></a>11.1.2. 多台服务器连接方案</h4><ul>
<li><p>提供数据方：master</p>
<ul>
<li>主服务器，主节点，主库</li>
<li>主客户端</li>
</ul>
</li>
<li><p>接收数据方：slave</p>
<ul>
<li>从服务器，从节点，从库</li>
<li>从客户端</li>
</ul>
</li>
<li><p>需要解决的问题：</p>
<ul>
<li>数据同步</li>
</ul>
</li>
<li><p>核心工作：</p>
<ul>
<li><p>master的数据复制到slave中</p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/%E4%B8%BB%E4%BB%8E_01.png" srcset="/img/loading.gif" lazyload alt="主从_01"></p>
</li>
</ul>
</li>
</ul>
<h3 id="11-1-3-主从复制的作用"><a href="#11-1-3-主从复制的作用" class="headerlink" title="11.1.3. 主从复制的作用"></a>11.1.3. 主从复制的作用</h3><p>主从复制即将master中的数据即时、有效的复制到slave中<br>特征：一个master可以拥有多个slave，一个slave只对应一个master</p>
<p>职责：</p>
<ul>
<li><p>master:</p>
<ul>
<li>写数据</li>
<li>执行写操作时，将出现变化的数据自动同步到slave</li>
<li> 读数据（可忽略）</li>
</ul>
</li>
<li><p>slave:</p>
<ul>
<li> 读数据</li>
<li>写数据（禁止）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/%E9%9B%86%E7%BE%A4.png" srcset="/img/loading.gif" lazyload alt="集群"></p>
</li>
<li><p>读写分离：master写、slave读，提高服务器的读写负载能力</p>
</li>
<li><p> 负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</p>
</li>
<li><p>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</p>
</li>
<li><p>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</p>
</li>
<li><p>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</p>
</li>
</ul>
<h2 id="11-2-主从复制工作流程"><a href="#11-2-主从复制工作流程" class="headerlink" title="11.2. 主从复制工作流程"></a>11.2. 主从复制工作流程</h2><p>主从复制过程大体可以分为3个阶段<br> 建立连接阶段（即准备阶段）<br> 数据同步阶段<br> 命令传播阶段</p>
<img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/主从流程_01.png" srcset="/img/loading.gif" lazyload alt="主从流程_01" style="zoom:67%;" />

<h3 id="11-2-1-阶段一：建立连接阶段"><a href="#11-2-1-阶段一：建立连接阶段" class="headerlink" title="11.2.1 阶段一：建立连接阶段"></a>11.2.1 阶段一：建立连接阶段</h3><ul>
<li> 建立slave到master的连接，使master能够识别slave，并保存slave端口号</li>
</ul>
<p>步骤1：设置master的地址和端口，客户端保存master信息<br>步骤2：建立socket连接<br>步骤3：发送ping命令（定时器任务）<br>步骤4：身份验证<br>步骤5：发送slave端口信息<br>至此，主从连接成功！<br><strong>状态：</strong><br>slave：保存master的地址与端口<br>master：保存slave的端口<br><strong>总体：</strong><br>之间创建了连接的socket</p>
<img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/stage_01.png" srcset="/img/loading.gif" lazyload alt="stage_01" style="zoom:67%;" />

<p>主从连接（slave连接master）：</p>
<ol>
<li><p>方式一：客户端发送命令</p>
<blockquote>
<p>slaveof <masterip> <masterport>  [从主动连接]</p>
</blockquote>
</li>
<li><p>方式二：启动服务器参数</p>
<blockquote>
<p>redis-server -slaveof <masterip> <masterport></p>
</blockquote>
</li>
<li><p>方式三：服务器配置</p>
<blockquote>
<p>slaveof <masterip> <masterport>   [在配置文件中配置，启动这个配置文件时，就会有主从结构]</p>
</blockquote>
</li>
</ol>
<p>主从断开连接:</p>
<ol>
<li><p>客户端发送命令</p>
<blockquote>
<p>slaveof no one</p>
<p>attention:   slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</p>
</blockquote>
</li>
</ol>
<ul>
<li> 授权访问</li>
</ul>
<table>
<thead>
<tr>
<th>1 master客户端发送命令设置密码</th>
<th>1 slave客户端发送命令设置密码</th>
</tr>
</thead>
<tbody><tr>
<td>requirepass <password></td>
<td>auth <password></td>
</tr>
<tr>
<td>2 master配置文件设置密码</td>
<td>2 slave配置文件设置密码</td>
</tr>
<tr>
<td>config set requirepass <password></td>
<td>masterauth <password></td>
</tr>
<tr>
<td>config get requirepass</td>
<td>3 slave启动服务器设置密码</td>
</tr>
<tr>
<td></td>
<td>redis-server –a <password></td>
</tr>
</tbody></table>
<h3 id="11-2-2-阶段二：数据同步阶段工作流程"><a href="#11-2-2-阶段二：数据同步阶段工作流程" class="headerlink" title="11.2.2 阶段二：数据同步阶段工作流程"></a>11.2.2 阶段二：数据同步阶段工作流程</h3><ul>
<li>在slave初次连接master后，复制master中的所有数据到slave</li>
<li> 将slave的数据库状态更新成master当前的数据库状态</li>
</ul>
<p>步骤1：请求同步数据<br>步骤2：创建RDB同步数据<br>步骤3：恢复RDB同步数据<br>步骤4：请求部分同步数据<br>步骤5：恢复部分同步数据<br>至此，数据同步工作完成！ </p>
<p><strong>状态：</strong><br>slave：具有master端全部数据，包含RDB过程接收的数据<br>master：保存slave当前数据同步的位置<br><strong>总体：</strong><br>之间完成了数据克隆</p>
<img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/stage_02.png" srcset="/img/loading.gif" lazyload alt="stage_02" style="zoom:67%;" />

<p><strong>数据同步阶段master说明</strong></p>
<ol>
<li><p>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</p>
</li>
<li><p>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</p>
</li>
</ol>
<blockquote>
<p>repl-backlog-size 1mb     [master修改复制缓冲区的大小]</p>
</blockquote>
<ol start="3">
<li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区</li>
</ol>
<p><strong>数据同步阶段slave说明</strong></p>
<ol>
<li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务</p>
<blockquote>
<p>slave-serve-stale-data yes|no</p>
</blockquote>
</li>
<li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p>
</li>
<li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</p>
</li>
<li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，数据一致性变差，应谨慎选择</p>
</li>
</ol>
<h3 id="11-2-3-命令传播阶段"><a href="#11-2-3-命令传播阶段" class="headerlink" title="11.2.3 命令传播阶段"></a>11.2.3 命令传播阶段</h3><ul>
<li><p>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的<br>状态，同步的动作称为命令传播</p>
</li>
<li><p>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</p>
</li>
</ul>
<p>不同情况发生时，命令传播阶段会采用不同的数据同步方法</p>
<ul>
<li> 网络闪断闪连           忽略</li>
<li>短时间网络中断        部分复制</li>
<li>长时间网络中断       全量复制</li>
</ul>
<p>部分复制的三个核心要素</p>
<ol>
<li><p>服务器的运行 id（run id）</p>
<blockquote>
<p>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</p>
<p>作用：运行id被用于在服务器间进行传输，识别身份如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</p>
<p>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid</p>
</blockquote>
</li>
<li><p> 主服务器的复制积压缓冲区</p>
</li>
</ol>
<blockquote>
<p>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</p>
</blockquote>
<ol start="3">
<li><p>主从服务器的复制偏移量</p>
<blockquote>
<p>概念：一个数字，描述复制缓冲区中的指令字节位置</p>
<p>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</p>
</blockquote>
</li>
</ol>
<p><font color='red'>数据同步+命令传播阶段工作流程</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/stage_23.png" srcset="/img/loading.gif" lazyload alt="stage_23"></p>
<h3 id="11-2-4-心跳机制"><a href="#11-2-4-心跳机制" class="headerlink" title="11.2.4 心跳机制"></a>11.2.4 心跳机制</h3><ul>
<li>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</li>
<li>master心跳：<ul>
<li>指令：PING</li>
<li> 周期：由repl-ping-slave-period决定，默认10秒</li>
<li> 作用：判断slave是否在线</li>
<li>查询：INFO replication  获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li>
</ul>
</li>
<li>slave心跳任务<ul>
<li> 指令：REPLCONF ACK {offset}</li>
<li> 周期：1秒</li>
<li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li>
<li> 作用2：判断master是否在线</li>
</ul>
</li>
</ul>
<h1 id="12-哨兵模式"><a href="#12-哨兵模式" class="headerlink" title="12. 哨兵模式"></a>12. 哨兵模式</h1><h2 id="12-1-哨兵简介"><a href="#12-1-哨兵简介" class="headerlink" title="12.1 哨兵简介"></a>12.1 哨兵简介</h2><p>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行<font color='cornflowerblue'>监控</font>，当出现故障时通过投票机制<font color='cornflowerblue'>选择</font>新的master并将所有slave连接到新的master。</p>
<p><strong>哨兵的作用</strong>    </p>
<ul>
<li>监控<ul>
<li>不断的检查master和slave是否正常运行。</li>
<li>master存活检测、master与slave运行情况检测</li>
</ul>
</li>
<li>通知（提醒）<ul>
<li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</li>
</ul>
</li>
<li>自动故障转移<ul>
<li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li>
</ul>
</li>
</ul>
<p><font color='cornflowerblue'>注意：</font></p>
<ul>
<li>哨兵也是一台redis服务器，只是不提供数据服务</li>
<li>通常哨兵配置数量为<font color='red'>单数</font></li>
</ul>
<h2 id="12-2-启动哨兵模式"><a href="#12-2-启动哨兵模式" class="headerlink" title="12.2 启动哨兵模式"></a>12.2 启动哨兵模式</h2><ul>
<li><p>配置一拖二的主从结构</p>
</li>
<li><p>配置三个哨兵（配置相同，端口不同）<br>参看sentinel.conf</p>
</li>
<li><p>启动哨兵</p>
<blockquote>
<p>redis-sentinel sentinel- 端口号 .conf</p>
</blockquote>
</li>
</ul>
<p>配置哨兵</p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sential_config.png" srcset="/img/loading.gif" lazyload alt="sential_config"></p>
<h2 id="12-3-哨兵工作原理"><a href="#12-3-哨兵工作原理" class="headerlink" title="12.3 哨兵工作原理"></a>12.3 哨兵工作原理</h2><p> 哨兵在进行主从切换过程中经历三个阶段</p>
<ul>
<li>监控</li>
<li>通知</li>
<li>故障转移</li>
</ul>
<h3 id="12-3-1-监控阶段"><a href="#12-3-1-监控阶段" class="headerlink" title="12.3.1 监控阶段"></a>12.3.1 监控阶段</h3><p>用于同步各个节点的状态信息</p>
<ul>
<li><p> 获取各个sentinel的状态（是否在线）</p>
</li>
<li><p> 获取master的状态</p>
</li>
<li><p>master属性</p>
</li>
<li><p>runid</p>
</li>
<li><p>role：master</p>
</li>
<li><p> 各个slave的详细信息</p>
</li>
<li><p>获取所有slave的状态（根据master中的slave信息）</p>
<ul>
<li> runid</li>
<li>role：slave</li>
<li> master_host、master_port</li>
<li> offset</li>
<li> ……</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sential_stage01.png" srcset="/img/loading.gif" lazyload alt="sential_stage01"  />

<h3 id="12-3-2-通知阶段"><a href="#12-3-2-通知阶段" class="headerlink" title="12.3.2 通知阶段"></a>12.3.2 通知阶段</h3><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sential_stage02.png" srcset="/img/loading.gif" lazyload alt="sential_stage02"></p>
<h3 id="12-3-3-故障转移阶段"><a href="#12-3-3-故障转移阶段" class="headerlink" title="12.3.3 故障转移阶段"></a>12.3.3 故障转移阶段</h3><p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/sential_stage03.png" srcset="/img/loading.gif" lazyload alt="sential_stage03"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/stage032.png" srcset="/img/loading.gif" lazyload alt="stage032"></p>
<p>选择了哨兵老大过后，选择相应的slave当选master</p>
<ul>
<li>服务器列表中挑选备选master<ul>
<li> 在线的</li>
<li>响应快的</li>
<li> 与原master断开时间短的</li>
<li>优先原则<ul>
<li> 优先级</li>
<li>offset</li>
<li>runid</li>
</ul>
</li>
</ul>
</li>
<li>发送指令（ sentinel ）<ul>
<li> 向新的master发送slaveof no one</li>
<li> 向其他slave发送slaveof 新masterIP端口</li>
</ul>
</li>
</ul>
<h3 id="12-4-总结"><a href="#12-4-总结" class="headerlink" title="12.4 总结"></a>12.4 总结</h3><ul>
<li> 监控</li>
<li> 同步信息</li>
<li>通知<ul>
<li> 保持联通   【sentinel和sentinel，sentinel和master和 slave】</li>
</ul>
</li>
<li>故障转移<ul>
<li> 发现问题</li>
<li>竞选负责人   【选取sentinel来处理故障】</li>
<li> 优选新master</li>
<li> 新master上任，其他slave切换master，原master作为slave故障回复后连接</li>
</ul>
</li>
</ul>
<h1 id="13-Cluster"><a href="#13-Cluster" class="headerlink" title="13. Cluster"></a>13. Cluster</h1><h2 id="13-1-集群简介"><a href="#13-1-集群简介" class="headerlink" title="13.1 集群简介"></a>13.1 集群简介</h2><p>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</p>
<p><strong>集群作用</strong></p>
<ul>
<li><p> 分散单台服务器的访问压力，实现负载均衡</p>
</li>
<li><p> 分散单台服务器的存储压力，实现可扩展性</p>
</li>
<li><p> 降低单台服务器宕机带来的业务灾难</p>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/cluster.png" srcset="/img/loading.gif" lazyload alt="cluster" style="zoom:67%;" />

<h2 id="13-2-redis集群结构设计"><a href="#13-2-redis集群结构设计" class="headerlink" title="13.2 redis集群结构设计"></a>13.2 redis集群结构设计</h2><ol>
<li>数据存储设计</li>
</ol>
<ul>
<li><p>通过算法设计，计算出key应该保存的位置</p>
</li>
<li><p>将所有的存储空间计划切割成16384份，每台主机保存一部分每份代表的是一个存储空间，不是一个key的保存空间</p>
</li>
<li><p>将key按照计算出的结果放到对应的存储空间【槽】</p>
<img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/slot_cal.png" srcset="/img/loading.gif" lazyload alt="slot_cal" style="zoom:67%;" /></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/slot.png" srcset="/img/loading.gif" lazyload alt="slot" style="zoom:50%;" />

<ol start="2">
<li>集群内部通讯设计</li>
</ol>
<ul>
<li><p>各个数据库相互通信，保存各个库中槽的编号数据</p>
</li>
<li><p>一次命中，直接返回</p>
</li>
<li><p>一次未命中，告知具体位置</p>
<img src="https://cdn.jsdelivr.net/gh/kusuzi/image-folder@master/Redis/cluster_com.png" srcset="/img/loading.gif" lazyload alt="cluster_com" style="zoom:67%;" /></li>
</ul>
<h2 id="13-3-cluster集群结构搭建"><a href="#13-3-cluster集群结构搭建" class="headerlink" title="13.3 cluster集群结构搭建"></a>13.3 cluster集群结构搭建</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CJ411m7Gc?p=104&spm_id_from=pageDriver">视频搭建教程</a></p>
<h1 id="14-企业级解决方案"><a href="#14-企业级解决方案" class="headerlink" title="14. 企业级解决方案"></a>14. 企业级解决方案</h1><h2 id="14-2-缓存预热"><a href="#14-2-缓存预热" class="headerlink" title="14.2 缓存预热"></a>14.2 缓存预热</h2><p><strong>问题</strong>：服务器启动后迅速宕机</p>
<p><strong>排查：</strong></p>
<ol>
<li>请求数量较高</li>
<li>主从之间数据吞吐量较大，数据同步操作频度较高</li>
</ol>
<p><strong>解决方案：</strong></p>
<p>前置准备工作：</p>
<ol>
<li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li>
<li>利用LRU数据删除策略，构建数据留存队列<br>例如：storm与kafka配合</li>
</ol>
<p>准备工作：</p>
<ol>
<li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li>
<li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li>
<li>热点数据主从同时预热</li>
</ol>
<p>实施：</p>
<ol>
<li>使用脚本程序固定触发数据预热过程</li>
<li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li>
</ol>
<p><strong>总结</strong>：缓存预热就是系统启动前，<font color='red'>提前将相关的缓存数据直接加载到缓存系统</font>。避免在用户请求的时候，先查询数据库，然后再将数据缓<br>存的问题！用户直接查询事先被预热的缓存数据！</p>
<h2 id="14-2-缓存雪崩"><a href="#14-2-缓存雪崩" class="headerlink" title="14.2 缓存雪崩"></a>14.2 缓存雪崩</h2><p><strong>问题</strong>：缓存雪崩描述的就是这样⼀个简单的场景：<strong>缓存在同⼀时间大面积的失效，后⾯的请求都直接落到了数据库上，</strong>造成数据库短时间内承受⼤量请求。 这就好⽐雪崩⼀样，摧枯拉朽之势，数据库的压⼒可想⽽知，可能直接就被这么多请求弄宕机了。</p>
<p><strong>解决方案：</strong></p>
<p>针对 Redis 服务不可⽤的情况：</p>
<ol>
<li>采⽤ Redis 集群，避免单机出现问题整个缓存服务都没办法使⽤。</li>
<li>限流，避免同时处理⼤量的请求。</li>
</ol>
<p>针对热点缓存失效的情况：</p>
<ol>
<li>数据有效期策略调整<ul>
<li>根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</li>
<li>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</li>
</ul>
</li>
<li>缓存永不失效。</li>
</ol>
<p><strong>总结：</strong>缓存雪崩就是<strong>瞬间过期数据量太大，导致对数据库服务器造成压力。</strong>如能够有效避免过期时间集中，可以有效解决雪崩现象的出现<br>（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p>
<h2 id="14-3-缓存击穿"><a href="#14-3-缓存击穿" class="headerlink" title="14.3 缓存击穿"></a>14.3 缓存击穿</h2><p><strong>问题：</strong></p>
<ol>
<li>Redis中<strong>某个key</strong>过期，该key访问量巨大</li>
<li>多个数据请求从服务器直接压到Redis后，均未命中</li>
<li>Redis在短时间内发起了大量对数据库中<strong>同一数据的访问</strong></li>
</ol>
<p><strong>解决方案：</strong></p>
<ol>
<li>预先设定<br>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长<br>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</li>
<li>现场调整<br>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li>
<li>后台刷新数据<br>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li>
<li>二级缓存<br>设置不同的失效时间，保障不会被同时淘汰就行</li>
<li>加锁<br>分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</li>
</ol>
<p><strong>总结</strong>：缓存击穿就是<strong>单个高热数据过期的瞬间，数据访问量较大</strong>，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度<br>较高，配合雪崩处理策略即可。</p>
<h2 id="14-4-缓存穿透"><a href="#14-4-缓存穿透" class="headerlink" title="14.4 缓存穿透"></a>14.4 缓存穿透</h2><p><strong>问题：</strong></p>
<ul>
<li>获取的数据在Redis和数据库中都不存在，数据库查询未得到对应数据</li>
<li>Redis获取到null数据未进行持久化，直接返回</li>
<li>下次此类数据到达重复上述过程</li>
<li>出现黑客攻击服务</li>
</ul>
<p><strong>解决方案：</strong></p>
<ol>
<li>缓存null【无效key】<br>对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</li>
<li>白名单策略</li>
</ol>
<ul>
<li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放<br>行，加载异常数据时直接拦截（效率偏低）</li>
<li> <strong>使用布隆过滤器</strong>（有关布隆过滤器的命中问题对当前状况可以忽略）</li>
</ul>
<ol start="3">
<li>实施监控<br> 实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比</li>
</ol>
<ul>
<li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</li>
<li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象<br>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li>
</ul>
<ol start="4">
<li>key加密<br> 问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验<br> 例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</li>
</ol>
<p>缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力,根本没有经过缓存这⼀层。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。</p>
<h2 id="14-5-性能指标监控"><a href="#14-5-性能指标监控" class="headerlink" title="14.5 性能指标监控"></a>14.5 性能指标监控</h2><ul>
<li> 性能指标：Performance</li>
<li> 内存指标：Memory</li>
<li> 基本活动指标：Basic activity</li>
<li>持久性指标：Persistence</li>
<li>错误指标：Error</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">Redis</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/learn/">learn</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/15/SpringBoot/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SpringBoot</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div> 像风一样自由</div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
